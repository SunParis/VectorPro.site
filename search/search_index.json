{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to VectorPro's Tutorial WebSite","text":"<p>Source code is here.</p>"},{"location":"#vector_pro","title":"vector_pro","text":"C++<pre><code>template &lt; class value_type &gt; class vector_pro; // generic template\n</code></pre> <p>Same as std::vectors, vector_pros are sequence containers representing arrays that can change in size.</p> <p>Vector_pros use contiguous storage locations for their elements. Unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.</p> <p>Don't have much differences with vectors, vector_pros use a dynamically allocated array to store their elements. Instead of reallocating each time an element is added to the container, vector_pro containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements. However we currently not support libraries to implement different strategies for memory growth, we just simply double the capacity at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity.</p> <p>Most of the above text are just copied from std::vector.</p>"},{"location":"#template-parameters","title":"Template parameters","text":"C++<pre><code>template &lt;class value_type&gt;\n</code></pre> <p>Only if <code>value_type</code> is guaranteed to not throw while moving, implementations can optimize to move elements instead of copying them during reallocations.</p>"},{"location":"#member-types-and-macros","title":"Member types and Macros","text":"member type definition notes <code>iterator_pro</code> a random access iterator to <code>value_type</code> convertible to <code>const_iterator</code> <code>const_iterator_pro</code> a random access iterator to <code>const value_type</code> <code>size_type</code> an unsigned integral type in a 64-bit system will be <code>int64_t</code>; 32-bit system will be <code>int32_t</code>; the others will just be <code>long int</code>. <code>VECTOR_PRO_DEFAULT_SIZE</code> initial size of a vector default will be 64, self-defined is available"},{"location":"#member-functions","title":"Member functions","text":"name notes (constructor) Construct vector (public member function) (destructor) Vector destructor (public member function) operator= Assign content (public member function)"},{"location":"#itertators","title":"Itertators","text":"name notes begin Return iterator to beginning (public member function) end Return iterator to end (public member function) rbegin Return reverse iterator to reverse beginning (public member function) rend Return reverse iterator to reverse end (public member function) cbegin Return const_iterator to beginning (public member function) cend Return const_iterator to end (public member function) crbegin Return const_reverse_iterator to reverse beginning (public member function) crend Return const_reverse_iterator to reverse end (public member function)"},{"location":"#capacity","title":"Capacity","text":"name notes size Return size (public member function) max_size Return maximum size (public member function) resize Change size (public member function) capacity Return size of allocated storage capacity (public member function) empty Test whether vector is empty (public member function) reserve Request a change in capacity (public member function) shrink_to_fit Shrink to fit (public member function)"},{"location":"#element-access","title":"Element access","text":"name notes operator[] Access element (public member function) at Access element (public member function) front Access first element (public member function) back Access last element (public member function) data Access data"},{"location":"#modifiers","title":"Modifiers","text":"name notes assign Assign vector content (public member function) push_back Add element at the end (public member function) pop_back Delete last element (public member function) insert Insert elements (public member function) erase Erase elements (public member function) swap Swap content (public member function) clear Clear content (public member function) emplace Construct and insert element (public member function) emplace_back Construct and insert element at the end (public member function)"},{"location":"#differences-from-stdvector","title":"Differences from std::vector","text":"name notes not_empty Test whether vector is not empty (public member function) push Add element at the end (public member function) pop Delete last element from the vector and return it back (public member function) merge Copy another vector to the end (public member function) find Find an element in the vector (public member function) sort Sort the vector (public member function) print Print the vector (public member function) operator&lt;&lt; Turn the vector into an <code>std::ostream</code> (public friend member function)"},{"location":"see_also/","title":"See Also","text":"<p>To learn more about std::vector.</p> <p>To visit out gihub page.</p>"},{"location":"functions/assign/","title":"vector_pro::assign","text":"C++<pre><code>// range\nvoid assign(iterator_pro&lt;value_type&gt; from, iterator_pro&lt;value_type&gt; exclude_to);\n// fill\nvoid assign(size_type num, const value_type&amp; val);\n// initializer list\nvoid assign(std::initializer_list&lt;value_type&gt; another);\n</code></pre>"},{"location":"functions/assign/#assign-vector-content","title":"Assign vector content","text":"<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.</p> <ol> <li> <p>range version the new contents are elements constructed from each of the elements in the range <code>[from, exclude_to)</code> , in the same order.</p> </li> <li> <p>fill version the new contents are <code>num</code> elements, each initialized to a copy of <code>val</code>.</p> </li> <li> <p>initializer list versionthe new contents are copies of the values passed as initializer list, in the same order.</p> </li> </ol>"},{"location":"functions/assign/#parameters","title":"Parameters","text":"<ol> <li><code>from</code>, <code>exclude_to</code>Input iterators to the initial and final positions in a sequence. The range used is <code>[from, exclude_to)</code>, which includes all the elements between <code>from</code> and <code>exclude_to</code> , including the element pointed by <code>from</code> but not the element pointed by <code>exclude_to</code>. </li> <li><code>num</code>New size for the container.</li> <li><code>val</code>Value to fill the container with.</li> <li><code>another</code>An <code>std::inializer_list</code> object of the same type.</li> </ol>"},{"location":"functions/assign/#example","title":"Example","text":"C++<pre><code>// vector_pro assign\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * Size of first: 7\n * Size of second: 5\n * Size of third: 3\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; first;\n  vector_pro&lt;int&gt; second;\n  vector_pro&lt;int&gt; third;\n\n  first.assign (7,100);             // 7 ints with a value of 100\n\n  iterator_pro&lt;int&gt; it;\n  it=first.begin()+1;\n\n  second.assign (it,first.end()-1); // the 5 central values of first\n\n  third.assign ({1, 2, 3});   // assigning from array.\n\n  std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/assign/#complexity","title":"Complexity","text":"<p>Linear on initial and final sizes (destructions, constructions).</p>"},{"location":"functions/at/","title":"vector_pro::at","text":"C++<pre><code>value_type&amp; at(const size_type position);\n</code></pre>"},{"location":"functions/at/#access-element","title":"Access element","text":"<p>Returns a reference to the element at <code>position</code> in the vector.</p> <p>The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not.</p>"},{"location":"functions/at/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position of an element in the container.</li> </ol>"},{"location":"functions/at/#return-value","title":"Return value","text":"<p>The reference of the element at the specified position in the container.</p>"},{"location":"functions/at/#example","title":"Example","text":"C++<pre><code>// vector_pro::at\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 0 1 2 3 4 5 6 7 8 9\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector(10, 0);   // 10 zero-initialized ints\n\n  // assign some values:\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    myvector.at(i)=i;\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector.at(i);\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/at/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/back/","title":"vector_pro::back","text":"C++<pre><code>value_type&amp; back();\n</code></pre>"},{"location":"functions/back/#access-element","title":"Access element","text":"<p>Returns a reference to the last element in the vector. </p> <p>Calling this function on an empty will get an exception .</p>"},{"location":"functions/back/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/back/#return-value","title":"Return value","text":"<p>A reference to the last element in the vector.</p>"},{"location":"functions/back/#example","title":"Example","text":"C++<pre><code>// vector_pro::back\n#include &lt;iostream&gt;\n#include \"../vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 10 9 8 7 6 5 4 3 2 1 0\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  myvector.push_back(10);\n\n  while (myvector.back() != 0)\n  {\n    myvector.push_back ( myvector.back() -1 );\n  }\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size() ; i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/back/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/begin/","title":"vector_pro::begin","text":"C++<pre><code>iterator_pro begin() noexcept;\n</code></pre>"},{"location":"functions/begin/#return-iterator-to-beginning","title":"Return iterator to beginning","text":"<p>Returns an iterator pointing to the first element in the vector.</p> <p>If the container is empty, the returned iterator value shall not be dereferenced.</p>"},{"location":"functions/begin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/begin/#return-value","title":"Return value","text":"<p>An iterator to the beginning of the sequence container.</p>"},{"location":"functions/begin/#example","title":"Example","text":"C++<pre><code>// vector_pro::begin/end\n#include &lt;iostream&gt;\n#include \"../vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 1 2 3 4 5\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  for (int i=1; i&lt;=5; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (iterator_pro&lt;int&gt; it = myvector.begin() ; it != myvector.end(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/begin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/capacity/","title":"vector_pro::capacity","text":"C++<pre><code>size_type capacity() const noexcept;\n</code></pre>"},{"location":"functions/capacity/#return-size-of-allocated-storage-capacity","title":"Return size of allocated storage capacity","text":"<p>Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.</p> <p>Notice that this capacity does not suppose a limit on the size of the vector. The theoretical limit on the size of a vector is given by member max_size.</p>"},{"location":"functions/capacity/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/capacity/#return-value","title":"Return value","text":"<p>The size of the currently allocated storage capacity in the vector, measured in terms of the number elements it can hold.</p>"},{"location":"functions/capacity/#example","title":"Example","text":"C++<pre><code>// comparing size, capacity and max_size\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * size: 100\n * capacity: 128\n * max_size: 9223372036854775807\n */\n\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some content in the vector:\n  for (int i=0; i&lt;100; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"max_size: \" &lt;&lt; (std::size_t) myvector.max_size() &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/capacity/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/cbegin/","title":"vector_pro::cbegin","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; cbegin() const noexcept;\n</code></pre>"},{"location":"functions/cbegin/#return-const_iterator-to-beginning","title":"Return const_iterator to beginning","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the first element in the container.</p> <p>Just like the <code>const_iterator</code> , which is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the <code>iterator_pro</code> returned by vector_pro::begin, but it cannot be used to modify the contents it points to, even if the vector object is not itself const.</p> <p>If the container is empty, the returned iterator value shall not be dereferenced.</p>"},{"location":"functions/cbegin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/cbegin/#return-value","title":"Return value","text":"<p>A <code>const_iterator</code> to the beginning of the sequence.</p>"},{"location":"functions/cbegin/#example","title":"Example","text":"C++<pre><code>// vector_pro::cbegin/cend\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 10 20 30 40 50\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30,40,50};\n\n  std::cout &lt;&lt; \"myvector contains:\";\n\n  for (auto it = myvector.cbegin(); it != myvector.cend(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/cbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/cend/","title":"vector_pro::cend","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; cend() const noexcept;\n</code></pre>"},{"location":"functions/cend/#return-const_iterator-to-beginning","title":"Return const_iterator to beginning","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the <code>past-the-end</code> in the container.</p> <p>Just like the <code>const_iterator</code> , which is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the <code>iterator_pro</code> returned by vector_pro::end, but it cannot be used to modify the contents it points to, even if the vector object is not itself const.</p> <p>If the container is empty, this function returns the same as vector_pro::cbegin.</p>"},{"location":"functions/cend/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/cend/#return-value","title":"Return value","text":"<p>A <code>const_iterator</code> to the end of the sequence.</p>"},{"location":"functions/cend/#example","title":"Example","text":"C++<pre><code>// vector_pro::cbegin/cend\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 10 20 30 40 50\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30,40,50};\n\n  std::cout &lt;&lt; \"myvector contains:\";\n\n  for (auto it = myvector.cbegin(); it != myvector.cend(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/cend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/clear/","title":"vector_pro::clear","text":"C++<pre><code>void clear() noexcept;\n</code></pre>"},{"location":"functions/clear/#return-const_iterator-to-beginning","title":"Return const_iterator to beginning","text":"<p>Removes all elements from the vector (which are destroyed), leaving the container with a size of <code>0</code>.</p>"},{"location":"functions/clear/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/clear/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/clear/#example","title":"Example","text":"C++<pre><code>// clearing vectors\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 100 200 300\n * myvector contains: 1101 2202\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  myvector.push_back (100);\n  myvector.push_back (200);\n  myvector.push_back (300);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  myvector.clear();\n  myvector.push_back (1101);\n  myvector.push_back (2202);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/clear/#complexity","title":"Complexity","text":"<p>Linear in size (destructions).</p>"},{"location":"functions/constructor/","title":"vector_pro::vector_pro","text":"C++<pre><code>vector_pro();\nvector_pro(const size_type len, const value_type&amp; val);\nvector_pro(const_iterator_pro&lt;value_type&gt;from, const_iterator_pro&lt;value_type&gt;exclude_to);\nvector_pro(const vector_pro&lt;value_type&gt;&amp; another);\nvector_pro(vector_pro&lt;value_type&gt;&amp;&amp; another);\nvector_pro(const std::vector&lt;value_type&gt;&amp; another);\nvector_pro(const std::initializer_list&lt;value_type&gt; &amp;another);\nvector_pro(const value_type *arr, const size_type len);\n</code></pre>"},{"location":"functions/constructor/#construct-vector","title":"Construct vector","text":"<p>Constructs a vector_pro, initializing its contents depending on the constructor version used:</p> <ol> <li> <p>default constructor Constructs an container, with <code>VECTOR_PRO_DEFAULT_SIZE</code>.</p> </li> <li> <p>fill constructor Constructs a container with <code>len</code> elements. Each element is a copy of <code>val</code> (if provided).</p> </li> <li> <p>range constructor Constructs a container with as many elements as the range <code>[from, exclude_to)</code> and in the same order.</p> </li> <li> <p>copy constructor Constructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>move constructor Constructs a container by moving each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>std::vector constructorConstructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>initializer list constructor Constructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>traditional array constructorConstructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> </ol>"},{"location":"functions/constructor/#parameters","title":"Parameters","text":"<ol> <li><code>len</code>Initial container size.</li> <li><code>val</code>Value to fill the container with.</li> <li><code>another</code>Another container object of the same type.Can be a <code>std::vector</code> , <code>std::inializer_list</code> or just another <code>vector_pro</code>.</li> <li><code>from</code>, <code>exclude_to</code><code>Iterators</code> to the initial and final positions in a range. The range used is <code>[from, exclude_to)</code>, which includes all the elements between <code>from</code> and <code>exclude_to</code> , including the element pointed by <code>from</code> but not the element pointed by <code>exclude_to</code>. </li> <li><code>arr</code>Traditional array.</li> </ol>"},{"location":"functions/constructor/#example","title":"Example","text":"C++<pre><code>// constructing vectors\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * The contents of fifth are: [ 100, 100, 100, 100 ]\n * While in fourth will be: [ null ]\n */\n\nint main () {\n  // constructors used in the same order as described above:\n\n  // empty vector_pro of ints\n  vector_pro&lt;int&gt; first;     \n\n  // four ints with value 100\n  vector_pro&lt;int&gt; second (4,100);                       \n\n  // iterating through second\n  vector_pro&lt;int&gt; third (second.begin(),second.end());  \n\n  // a copy of third\n  vector_pro&lt;int&gt; fourth (third);\n\n  // a `move` from fourth\n  vector_pro&lt;int&gt; fifth (std::move(fourth));\n  std::cout &lt;&lt; \"The contents of fifth are: \" &lt;&lt; fifth &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"While in fourth will be: \" &lt;&lt; fourth &lt;&lt; std::endl;\n\n  // a copy from std::vector\n  std::vector&lt;int&gt; myints = {1, 2, 3, 4, 5};\n  vector_pro&lt;int&gt; sixth (myints);\n\n  // a copy from initializer list\n  vector_pro&lt;int&gt; seventh = {1, 2, 3, 4, 5};\n\n  // a copy from traditional array\n  int arr[5] = {0, 1, 2, 3, 4};\n  vector_pro&lt;int&gt; eighth (arr, 5);\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/constructor/#complexity","title":"Complexity","text":"<p>Constant for the <code>default constructor</code> (1), and for the <code>move constructors</code> (3) . For all other cases, linear in the resulting container size.</p>"},{"location":"functions/crbegin/","title":"vector_pro::crbegin","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; crbegin() const noexcept;\n</code></pre>"},{"location":"functions/crbegin/#return-const_iterator-to-reverse-beginning","title":"Return const_iterator to reverse beginning","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the last element in the container and grows in a reverse way. </p>"},{"location":"functions/crbegin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/crbegin/#return-value","title":"Return value","text":"<p>A <code>const_reverse_iterator</code> to the reverse beginning of the sequence.</p>"},{"location":"functions/crbegin/#example","title":"Example","text":"C++<pre><code>// vector_pro::crbegin/crend\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector backwards: 5 4 3 2 1\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {1,2,3,4,5};\n\n  std::cout &lt;&lt; \"myvector backwards:\";\n  for (auto rit = myvector.crbegin(); rit != myvector.crend(); ++rit)\n    std::cout &lt;&lt; ' ' &lt;&lt; *rit;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/crbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/crend/","title":"vector_pro::crend","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; crend() const noexcept;\n</code></pre>"},{"location":"functions/crend/#return-const_iterator-to-reverse-end","title":"Return const_iterator to reverse end","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the first element in the container and grows in a reverse way. </p>"},{"location":"functions/crend/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/crend/#return-value","title":"Return value","text":"<p>A <code>const_reverse_iterator</code> to the reverse end of the sequence.</p>"},{"location":"functions/crend/#example","title":"Example","text":"C++<pre><code>// vector_pro::crbegin/crend\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector backwards: 5 4 3 2 1\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {1,2,3,4,5};\n\n  std::cout &lt;&lt; \"myvector backwards:\";\n  for (auto rit = myvector.crbegin(); rit != myvector.crend(); ++rit)\n    std::cout &lt;&lt; ' ' &lt;&lt; *rit;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/crend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/data/","title":"vector_pro::data","text":"C++<pre><code>value_type *data() always_except;\n</code></pre>"},{"location":"functions/data/#do-nothing","title":"Do nothing","text":"<p>Due to the data structure used in <code>vector_pro</code>, <code>vector_pro</code> doesn't support this operation yet. (Maybe in the near future ?) </p>"},{"location":"functions/data/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/data/#return-value","title":"Return value","text":"<p>Throw an exception.</p>"},{"location":"functions/data/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/destructor/","title":"vector_pro::~vector_pro","text":"C++<pre><code>~vector_pro();\n</code></pre>"},{"location":"functions/destructor/#destruct-vector","title":"Destruct vector","text":"<p>Destroys the container object, after destructs each element by calling <code>~value_type()</code> (if has).</p>"},{"location":"functions/destructor/#complexity","title":"Complexity","text":"<p>Linear in size (destructors).</p>"},{"location":"functions/emplace/","title":"vector_pro::emplace","text":"C++<pre><code>size_type emplace(size_type position, const value_type&amp; val);\niterator_pro&lt;value_type&gt; emplace(const_iterator_pro&lt;value_type&gt; position, const value_type&amp; val);\n</code></pre>"},{"location":"functions/emplace/#construct-and-insert-element","title":"Construct and insert element","text":"<p>The container is extended by inserting a new element <code>val</code> at <code>position</code>. </p> <p>This effectively increases the container size by one.</p> <p>An automatic reallocation of the allocated storage space happens if -and only if- the new vector size surpasses the current vector capacity.</p> <p>A similar member function exists, insert, which either copies or moves existing objects into the container.</p>"},{"location":"functions/emplace/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position in the container where the new element is inserted.Can be a <code>unsigned long</code> or an <code>(const_)iterator_pro</code>.</li> <li><code>val</code>Value of the new element.</li> </ol>"},{"location":"functions/emplace/#return-value","title":"Return value","text":"<p>Type will be same as the position. (<code>size_type</code> / <code>iterator_pro</code>)</p>"},{"location":"functions/emplace/#example","title":"Example","text":"C++<pre><code>// vector_pro::emplace\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 10 200 100 20 30 300\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30};\n\n  auto it = myvector.emplace ( myvector.begin()+1, 100 );\n  myvector.emplace ( it, 200 );\n  myvector.emplace ( myvector.end(), 300 );\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (auto&amp; x: myvector)\n    std::cout &lt;&lt; ' ' &lt;&lt; x;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/emplace/#complexity","title":"Complexity","text":"<p>Linear on the number of elements after position (moving).</p>"},{"location":"functions/emplace_back/","title":"vector_pro::emplace","text":"C++<pre><code>size_type emplace_back(const value_type&amp; val);\n</code></pre>"},{"location":"functions/emplace_back/#construct-and-insert-element-at-the-end","title":"Construct and insert element at the end","text":"<p>Inserts a new element at the end of the vector, right after its current last element.</p> <p>A similar member function exists, push_back, which either copies or moves an existing object into the container.</p>"},{"location":"functions/emplace_back/#parameters","title":"Parameters","text":"<ol> <li><code>val</code>Value of the new element.</li> </ol>"},{"location":"functions/emplace_back/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/emplace_back/#example","title":"Example","text":"C++<pre><code>// vector_pro::emplace_back\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 10 20 30 100 200\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30};\n\n  myvector.emplace_back (100);\n  myvector.emplace_back (200);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (auto&amp; x: myvector)\n    std::cout &lt;&lt; ' ' &lt;&lt; x;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/emplace_back/#complexity","title":"Complexity","text":"<p>Constant (amortized time, reallocation may happen).</p>"},{"location":"functions/empty/","title":"vector_pro::empty","text":"C++<pre><code>bool empty() const noexcept;\n</code></pre>"},{"location":"functions/empty/#test-whether-vector-is-empty","title":"Test whether vector is empty","text":"<p>Returns whether the vector is empty (i.e. whether its size is <code>0</code>).</p>"},{"location":"functions/empty/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/empty/#return-value","title":"Return value","text":"<p><code>true</code> if the container size is <code>0</code>, <code>false</code> otherwise.</p>"},{"location":"functions/empty/#example","title":"Example","text":"C++<pre><code>// vector_pro::empty/not_empty\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * total: 55\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  int sum (0);\n\n  for (int i=1;i&lt;=10;i++) myvector.push_back(i);\n\n  while (!myvector.empty() &amp;&amp; myvector.not_empty())\n  {\n     sum += myvector.back();\n     myvector.pop_back();\n  }\n\n  std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/empty/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/end/","title":"vector_pro::end","text":"C++<pre><code>iterator_pro end() noexcept;\n</code></pre>"},{"location":"functions/end/#return-iterator-to-beginning","title":"Return iterator to beginning","text":"<p>Returns an iterator pointing to the <code>past-the-end</code> element in the vector.</p> <p>If the container is empty, the returned iterator value shall not be dereferenced.</p>"},{"location":"functions/end/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/end/#return-value","title":"Return value","text":"<p>An iterator to the element past the end of the sequence.</p>"},{"location":"functions/end/#example","title":"Example","text":"C++<pre><code>// vector_pro::begin/end\n#include &lt;iostream&gt;\n#include \"../vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 1 2 3 4 5\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  for (int i=1; i&lt;=5; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (iterator_pro&lt;int&gt; it = myvector.begin() ; it != myvector.end(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/end/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/function_name/","title":"function_name","text":"C++<pre><code>// code\n</code></pre>"},{"location":"functions/function_name/#construct-vector","title":"Construct vector","text":"<p>//</p>"},{"location":"functions/function_name/#parameters","title":"Parameters","text":"<p>//</p>"},{"location":"functions/function_name/#example","title":"Example","text":"C++<pre><code>// code\n</code></pre> <p>//</p>"},{"location":"functions/function_name/#complexity","title":"Complexity","text":"<p>///</p>"},{"location":"tests/test1/","title":"test_title","text":"<p>// intro</p>"},{"location":"tests/test1/#test-code","title":"Test Code","text":"C++<pre><code>// code\n</code></pre> <p>///</p>"},{"location":"tests/test1/#result","title":"Result","text":"<p>///</p>"}]}