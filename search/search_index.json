{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to VectorPro's Tutorial WebSite","text":"<p>Source code is here.</p>"},{"location":"#vector_pro","title":"vector_pro","text":"C++<pre><code>template &lt; class value_type &gt; class vector_pro; // generic template\n</code></pre> <p>Same as std::vectors, vector_pros are sequence containers representing arrays that can change in size.</p> <p>Vector_pros use contiguous storage locations for their elements. Unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.</p> <p>Don't have much differences with vectors, vector_pros use a dynamically allocated array to store their elements. Instead of reallocating each time an element is added to the container, vector_pro containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements. However we currently not support libraries to implement different strategies for memory growth, we just simply double the capacity at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity.</p> <p>Most of the above text are just copied from std::vector.</p>"},{"location":"#template-parameters","title":"Template parameters","text":"C++<pre><code>template &lt;class value_type&gt;\n</code></pre> <p>Only if <code>value_type</code> is guaranteed to not throw while moving, implementations can optimize to move elements instead of copying them during reallocations.</p>"},{"location":"#member-types-and-macros","title":"Member types and Macros","text":"member type definition notes <code>iterator_pro</code> a random access iterator to <code>value_type</code> convertible to <code>const_iterator</code> <code>const_iterator_pro</code> a random access iterator to <code>const value_type</code> <code>size_type</code> an unsigned integral type in a 64-bit system will be <code>int64_t</code>; 32-bit system will be <code>int32_t</code>; the others will just be <code>long int</code>. <code>VECTOR_PRO_DEFAULT_SIZE</code> initial size of a vector default will be 64, self-defined is available"},{"location":"#member-functions","title":"Member functions","text":"name notes (constructor) Construct vector (public member function) (destructor) Vector destructor (public member function) operator= Assign content (public member function)"},{"location":"#itertators","title":"Itertators","text":"name notes begin Return iterator to beginning (public member function) end Return iterator to end (public member function) rbegin Return reverse iterator to reverse beginning (public member function) rend Return reverse iterator to reverse end (public member function) cbegin Return const_iterator to beginning (public member function) cend Return const_iterator to end (public member function) crbegin Return const_reverse_iterator to reverse beginning (public member function) crend Return const_reverse_iterator to reverse end (public member function)"},{"location":"#capacity","title":"Capacity","text":"name notes size Return size (public member function) max_size Return maximum size (public member function) resize Change size (public member function) capacity Return size of allocated storage capacity (public member function) empty Test whether vector is empty (public member function) reserve Request a change in capacity (public member function) shrink_to_fit Shrink to fit (public member function)"},{"location":"#element-access","title":"Element access","text":"name notes operator[] Access element (public member function) at Access element (public member function) front Access first element (public member function) back Access last element (public member function) data Access data"},{"location":"#modifiers","title":"Modifiers","text":"name notes assign Assign vector content (public member function) push_back Add element at the end (public member function) pop_back Delete last element (public member function) insert Insert elements (public member function) erase Erase elements (public member function) swap Swap content (public member function) clear Clear content (public member function) emplace Construct and insert element (public member function) emplace_back Construct and insert element at the end (public member function)"},{"location":"#differences-from-stdvector","title":"Differences from std::vector","text":"name notes not_empty Test whether vector is not empty (public member function) push Add element at the end (public member function) pop Delete last element from the vector and return it back (public member function) merge Copy another vector to the end (public member function) find Find an element in the vector (public member function) sort Sort the vector (public member function) print Print the vector (public member function) operator&lt;&lt; Turn the vector into an <code>std::ostream</code> (public friend member function)"},{"location":"see_also/","title":"See Also","text":"<p>To learn more about std::vector.</p> <p>To visit out gihub page.</p>"},{"location":"functions/assign/","title":"vector_pro::assign","text":"C++<pre><code>// range\nvoid assign(iterator_pro&lt;value_type&gt; from, iterator_pro&lt;value_type&gt; exclude_to);\n// fill\nvoid assign(size_type num, const value_type&amp; val);\n// initializer list\nvoid assign(std::initializer_list&lt;value_type&gt; another);\n</code></pre>"},{"location":"functions/assign/#assign-vector-content","title":"Assign vector content","text":"<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.</p> <ol> <li> <p>range version the new contents are elements constructed from each of the elements in the range <code>[from, exclude_to)</code> , in the same order.</p> </li> <li> <p>fill version the new contents are <code>num</code> elements, each initialized to a copy of <code>val</code>.</p> </li> <li> <p>initializer list versionthe new contents are copies of the values passed as initializer list, in the same order.</p> </li> </ol>"},{"location":"functions/assign/#parameters","title":"Parameters","text":"<ol> <li><code>from</code>, <code>exclude_to</code>Input iterators to the initial and final positions in a sequence. The range used is <code>[from, exclude_to)</code>, which includes all the elements between <code>from</code> and <code>exclude_to</code> , including the element pointed by <code>from</code> but not the element pointed by <code>exclude_to</code>. </li> <li><code>num</code>New size for the container.</li> <li><code>val</code>Value to fill the container with.</li> <li><code>another</code>An <code>std::inializer_list</code> object of the same type.</li> </ol>"},{"location":"functions/assign/#example","title":"Example","text":"C++<pre><code>// vector_pro assign\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * Size of first: 7\n * Size of second: 5\n * Size of third: 3\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; first;\n  vector_pro&lt;int&gt; second;\n  vector_pro&lt;int&gt; third;\n\n  first.assign (7,100);             // 7 ints with a value of 100\n\n  iterator_pro&lt;int&gt; it;\n  it=first.begin()+1;\n\n  second.assign (it,first.end()-1); // the 5 central values of first\n\n  third.assign ({1, 2, 3});   // assigning from array.\n\n  std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/assign/#complexity","title":"Complexity","text":"<p>Linear on initial and final sizes (destructions, constructions).</p>"},{"location":"functions/at/","title":"vector_pro::at","text":"C++<pre><code>value_type&amp; at(const size_type position);\n</code></pre>"},{"location":"functions/at/#access-element","title":"Access element","text":"<p>Returns a reference to the element at <code>position</code> in the vector.</p> <p>The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not.</p>"},{"location":"functions/at/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position of an element in the container..</li> </ol>"},{"location":"functions/at/#return-value","title":"Return value","text":"<p>The reference of the element at the specified position in the container.</p>"},{"location":"functions/at/#example","title":"Example","text":"C++<pre><code>// vector_pro::at\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * myvector contains: 0 1 2 3 4 5 6 7 8 9\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector(10, 0);   // 10 zero-initialized ints\n\n  // assign some values:\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    myvector.at(i)=i;\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector.at(i);\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/at/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/constructor/","title":"vector_pro::vector_pro","text":"C++<pre><code>vector_pro();\nvector_pro(const size_type len, const value_type&amp; val);\nvector_pro(const_iterator_pro&lt;value_type&gt;from, const_iterator_pro&lt;value_type&gt;exclude_to);\nvector_pro(const vector_pro&lt;value_type&gt;&amp; another);\nvector_pro(vector_pro&lt;value_type&gt;&amp;&amp; another);\nvector_pro(const std::vector&lt;value_type&gt;&amp; another);\nvector_pro(const std::initializer_list&lt;value_type&gt; &amp;another);\nvector_pro(const value_type *arr, const size_type len);\n</code></pre>"},{"location":"functions/constructor/#construct-vector","title":"Construct vector","text":"<p>Constructs a vector_pro, initializing its contents depending on the constructor version used:</p> <ol> <li> <p>default constructor Constructs an container, with <code>VECTOR_PRO_DEFAULT_SIZE</code>.</p> </li> <li> <p>fill constructor Constructs a container with <code>len</code> elements. Each element is a copy of <code>val</code> (if provided).</p> </li> <li> <p>range constructor Constructs a container with as many elements as the range <code>[from, exclude_to)</code> and in the same order.</p> </li> <li> <p>copy constructor Constructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>move constructor Constructs a container by moving each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>std::vector constructorConstructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>initializer list constructor Constructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>traditional array constructorConstructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> </ol>"},{"location":"functions/constructor/#parameters","title":"Parameters","text":"<ol> <li><code>len</code>Initial container size.</li> <li><code>val</code>Value to fill the container with.</li> <li><code>another</code>Another container object of the same type.Can be a <code>std::vector</code> , <code>std::inializer_list</code> or just another <code>vector_pro</code>.</li> <li><code>from</code>, <code>exclude_to</code><code>Iterators</code> to the initial and final positions in a range. The range used is <code>[from, exclude_to)</code>, which includes all the elements between <code>from</code> and <code>exclude_to</code> , including the element pointed by <code>from</code> but not the element pointed by <code>exclude_to</code>. </li> <li><code>arr</code>Traditional array.</li> </ol>"},{"location":"functions/constructor/#example","title":"Example","text":"C++<pre><code>// constructing vectors\n#include &lt;iostream&gt;\n#include \"vector_pro.hpp\"\n\n/**\n * Output:\n * The contents of fifth are: [ 100, 100, 100, 100 ]\n * While in fourth will be: [ null ]\n */\n\nint main () {\n  // constructors used in the same order as described above:\n\n  // empty vector_pro of ints\n  vector_pro&lt;int&gt; first;     \n\n  // four ints with value 100\n  vector_pro&lt;int&gt; second (4,100);                       \n\n  // iterating through second\n  vector_pro&lt;int&gt; third (second.begin(),second.end());  \n\n  // a copy of third\n  vector_pro&lt;int&gt; fourth (third);\n\n  // a `move` from fourth\n  vector_pro&lt;int&gt; fifth (std::move(fourth));\n  std::cout &lt;&lt; \"The contents of fifth are: \" &lt;&lt; fifth &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"While in fourth will be: \" &lt;&lt; fourth &lt;&lt; std::endl;\n\n  // a copy from std::vector\n  std::vector&lt;int&gt; myints = {1, 2, 3, 4, 5};\n  vector_pro&lt;int&gt; sixth (myints);\n\n  // a copy from initializer list\n  vector_pro&lt;int&gt; seventh = {1, 2, 3, 4, 5};\n\n  // a copy from traditional array\n  int arr[5] = {0, 1, 2, 3, 4};\n  vector_pro&lt;int&gt; eighth (arr, 5);\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/constructor/#complexity","title":"Complexity","text":"<p>Constant for the <code>default constructor</code> (1), and for the <code>move constructors</code> (3) . For all other cases, linear in the resulting container size.</p>"},{"location":"functions/destructor/","title":"vector_pro::~vector_pro","text":"C++<pre><code>~vector_pro();\n</code></pre>"},{"location":"functions/destructor/#destruct-vector","title":"Destruct vector","text":"<p>Destroys the container object, after destructs each element by calling <code>~value_type()</code> (if has).</p>"},{"location":"functions/destructor/#complexity","title":"Complexity","text":"<p>Linear in size (destructors).</p>"},{"location":"functions/function_name/","title":"function_name","text":"C++<pre><code>// code\n</code></pre>"},{"location":"functions/function_name/#construct-vector","title":"Construct vector","text":"<p>//</p>"},{"location":"functions/function_name/#parameters","title":"Parameters","text":"<p>//</p>"},{"location":"functions/function_name/#example","title":"Example","text":"C++<pre><code>// code\n</code></pre> <p>//</p>"},{"location":"functions/function_name/#complexity","title":"Complexity","text":"<p>///</p>"},{"location":"tests/test1/","title":"test_title","text":"<p>// intro</p>"},{"location":"tests/test1/#test-code","title":"Test Code","text":"C++<pre><code>// code\n</code></pre> <p>///</p>"},{"location":"tests/test1/#result","title":"Result","text":"<p>///</p>"}]}