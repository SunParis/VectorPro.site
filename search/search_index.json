{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to VectorPro's Tutorial WebSite","text":"<p>Source code is here.</p>"},{"location":"#vector_pro","title":"vector_pro","text":"C++<pre><code>template &lt; class value_type &gt; class vector_pro; // generic template\n</code></pre> <p>Same as std::vectors, vector_pros are sequence containers representing arrays that can change in size.</p> <p>Vector_pros use contiguous storage locations for their elements. Unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.</p> <p>Don't have much differences with vectors, vector_pros use a dynamically allocated array to store their elements. Instead of reallocating each time an element is added to the container, vector_pro containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements. However we currently not support libraries to implement different strategies for memory growth, we just simply double the capacity at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity.</p> <p>Most of the above text are just copied from <code>std::vector</code> .</p>"},{"location":"#template-parameters","title":"Template parameters","text":"C++<pre><code>template &lt;class value_type&gt;\n</code></pre> <p>Only if <code>value_type</code> is guaranteed to not throw while moving, implementations can optimize to move elements instead of copying them during reallocations.</p>"},{"location":"#member-types-and-macros","title":"Member types and Macros","text":"member type definition notes <code>iterator_pro</code> a random access iterator to <code>value_type</code> convertible to <code>const_iterator_pro</code>, more info in <code>iterator_pro</code> <code>const_iterator_pro</code> a random access iterator to <code>const value_type</code> more info in <code>iterator_pro</code> <code>vector_pro_exception</code> exception inherits from <code>std::exception</code>, more info in <code>vector_pro_exception</code> <code>size_type</code> an unsigned integral type in a 64-bit system will be <code>int64_t</code>; 32-bit system will be <code>int32_t</code>; the others will just be <code>long int</code>. <code>VECTOR_PRO_DEFAULT_SIZE</code> initial size of a vector default will be 64, self-defined is available"},{"location":"#member-functions","title":"Member functions","text":"name notes (constructor) Construct vector (public member function) (destructor) Vector destructor (public member function) operator= Assign content (public member function)"},{"location":"#itertators","title":"Itertators","text":"name notes begin Return an iterator to beginning (public member function) end Return an iterator to end (public member function) rbegin Return a reverse iterator to reverse beginning (public member function) rend Return a reverse iterator to reverse end (public member function) cbegin Return a const iterator to beginning (public member function) cend Return a const iterator to end (public member function) crbegin Return a const reverse iterator to reverse beginning (public member function) crend Return a const reverse iterator to reverse end (public member function)"},{"location":"#capacity","title":"Capacity","text":"name notes size Return size (public member function) max_size Return maximum size (public member function) resize Change size (public member function) capacity Return size of allocated storage capacity (public member function) empty Test whether vector is empty (public member function) reserve Request a change in capacity (public member function) shrink_to_fit Shrink to fit (public member function)"},{"location":"#element-access","title":"Element access","text":"name notes operator[] Access element (public member function) at Access element (public member function) front Access first element (public member function) back Access last element (public member function) data Access data"},{"location":"#modifiers","title":"Modifiers","text":"name notes assign Assign vector content (public member function) push_back Add element at the end (public member function) pop_back Delete last element (public member function) insert Insert elements (public member function) erase Erase elements (public member function) swap Swap content (public member function) clear Clear content (public member function) emplace Construct and insert element (public member function) emplace_back Construct and insert element at the end (public member function)"},{"location":"#differences-from-stdvector","title":"Differences from std::vector","text":"name notes not_empty Test whether vector is not empty (public member function) push Add element at the end (public member function) pop Delete last element from the vector and return it back (public member function) merge Copy another vector to the end (public member function) find Find an element in the vector (public member function) sort Sort the vector (public member function) print Print the vector (public member function) operator&lt;&lt; Turn the vector into an <code>std::ostream</code> (public friend member function) destroy Destroy the vector"},{"location":"see_also/","title":"See Also","text":"<p><code>std::vector</code></p> <p>CheeEn Yu</p>"},{"location":"functions/assign/","title":"vector_pro::assign","text":"C++<pre><code>// range\nvoid assign(iterator_pro&lt;value_type&gt; from, iterator_pro&lt;value_type&gt; exclude_to);\n// fill\nvoid assign(size_type num, const value_type&amp; val);\n// initializer list\nvoid assign(std::initializer_list&lt;value_type&gt; another);\n</code></pre>"},{"location":"functions/assign/#assign-vector-content","title":"Assign vector content","text":"<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.</p> <ol> <li> <p>range version the new contents are elements constructed from each of the elements in the range <code>[from, exclude_to)</code> , in the same order.</p> </li> <li> <p>fill version the new contents are <code>num</code> elements, each initialized to a copy of <code>val</code>.</p> </li> <li> <p>initializer list versionthe new contents are copies of the values passed as initializer list, in the same order.</p> </li> </ol>"},{"location":"functions/assign/#parameters","title":"Parameters","text":"<ol> <li><code>from</code>, <code>exclude_to</code>Input iterators to the initial and final positions in a sequence. The range used is <code>[from, exclude_to)</code>, which includes all the elements between <code>from</code> and <code>exclude_to</code> , including the element pointed by <code>from</code> but not the element pointed by <code>exclude_to</code>. </li> <li><code>num</code>New size for the container.</li> <li><code>val</code>Value to fill the container with.</li> <li><code>another</code>An <code>std::inializer_list</code> object of the same type.</li> </ol>"},{"location":"functions/assign/#example","title":"Example","text":"C++<pre><code>// vector_pro assign\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * Size of first: 7\n * Size of second: 5\n * Size of third: 3\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; first;\n  vector_pro&lt;int&gt; second;\n  vector_pro&lt;int&gt; third;\n\n  first.assign (7,100);             // 7 ints with a value of 100\n\n  iterator_pro&lt;int&gt; it;\n  it=first.begin()+1;\n\n  second.assign (it,first.end()-1); // the 5 central values of first\n\n  third.assign ({1, 2, 3});   // assigning from array.\n\n  std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/assign/#complexity","title":"Complexity","text":"<p>Linear on initial and final sizes (destructions, constructions).</p>"},{"location":"functions/at/","title":"vector_pro::at","text":"C++<pre><code>value_type&amp; at(const size_type position);\n</code></pre>"},{"location":"functions/at/#access-element","title":"Access element","text":"<p>Returns a reference to the element at <code>position</code> in the vector.</p> <p>Please note that the function automatically checks whether <code>position</code> is within the bounds of valid elements in the vector, and will throw an exception if it is not.</p>"},{"location":"functions/at/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position of an element in the container.</li> </ol>"},{"location":"functions/at/#return-value","title":"Return value","text":"<p>The reference of the element at the specified position in the container.</p>"},{"location":"functions/at/#example","title":"Example","text":"C++<pre><code>// vector_pro::at\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 0 1 2 3 4 5 6 7 8 9\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector(10, 0);   // 10 zero-initialized ints\n\n  // assign some values:\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    myvector.at(i)=i;\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector.at(i);\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/at/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/back/","title":"vector_pro::back","text":"C++<pre><code>value_type&amp; back();\n</code></pre>"},{"location":"functions/back/#access-element","title":"Access element","text":"<p>Returns a reference to the last element in the vector. </p> <p>Please note that calling this function on an empty container will get an exception .</p>"},{"location":"functions/back/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/back/#return-value","title":"Return value","text":"<p>A reference to the last element in the vector.</p>"},{"location":"functions/back/#example","title":"Example","text":"C++<pre><code>// vector_pro::back\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 10 9 8 7 6 5 4 3 2 1 0\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  myvector.push_back(10);\n\n  while (myvector.back() != 0)\n  {\n    myvector.push_back ( myvector.back() -1 );\n  }\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size() ; i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/back/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/begin/","title":"vector_pro::begin","text":"C++<pre><code>iterator_pro begin() noexcept;\n</code></pre>"},{"location":"functions/begin/#return-iterator-to-beginning","title":"Return iterator to beginning","text":"<p>Returns an iterator pointing to the first element in the vector.</p> <p>If the container is empty, the returned iterator value shall not be dereferenced.</p>"},{"location":"functions/begin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/begin/#return-value","title":"Return value","text":"<p>An iterator to the beginning of the sequence container.</p>"},{"location":"functions/begin/#example","title":"Example","text":"C++<pre><code>// vector_pro::begin/end\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 1 2 3 4 5\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  for (int i=1; i&lt;=5; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (iterator_pro&lt;int&gt; it = myvector.begin() ; it != myvector.end(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/begin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/capacity/","title":"vector_pro::capacity","text":"C++<pre><code>size_type capacity() const noexcept;\n</code></pre>"},{"location":"functions/capacity/#return-size-of-allocated-storage-capacity","title":"Return size of allocated storage capacity","text":"<p>Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.</p> <p>Notice that this capacity does not suppose a limit on the size of the vector. The theoretical limit on the size of a vector is given by member max_size.</p>"},{"location":"functions/capacity/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/capacity/#return-value","title":"Return value","text":"<p>The size of the currently allocated storage capacity in the vector, measured in terms of the number elements it can hold.</p>"},{"location":"functions/capacity/#example","title":"Example","text":"C++<pre><code>// comparing size, capacity and max_size\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * size: 100\n * capacity: 128\n * max_size: 9223372036854775807\n */\n\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some content in the vector:\n  for (int i=0; i&lt;100; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"max_size: \" &lt;&lt; (std::size_t) myvector.max_size() &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/capacity/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/cbegin/","title":"vector_pro::cbegin","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; cbegin() const noexcept;\n</code></pre>"},{"location":"functions/cbegin/#return-const_iterator-to-beginning","title":"Return const_iterator to beginning","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the first element in the container.</p> <p>Similar to <code>const_iterator</code> , which is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the <code>iterator_pro</code> which is returned by <code>vector_pro::begin</code>, but it cannot be used to modify the contents it points to, even if the vector object is not itself const.</p> <p>If the container is empty, the returned iterator value shall not be dereferenced.</p>"},{"location":"functions/cbegin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/cbegin/#return-value","title":"Return value","text":"<p>A <code>const_iterator_pro</code>  to the beginning of the sequence.</p>"},{"location":"functions/cbegin/#example","title":"Example","text":"C++<pre><code>// vector_pro::cbegin/cend\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 10 20 30 40 50\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30,40,50};\n\n  std::cout &lt;&lt; \"myvector contains:\";\n\n  for (auto it = myvector.cbegin(); it != myvector.cend(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/cbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/cend/","title":"vector_pro::cend","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; cend() const noexcept;\n</code></pre>"},{"location":"functions/cend/#return-const_iterator-to-beginning","title":"Return const_iterator to beginning","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the <code>past-the-end</code> in the container.</p> <p>Just like the <code>const_iterator</code> , which is an iterator that points to const content. This iterator can be increased and decreased (unless it is itself also const), just like the <code>iterator_pro</code> which is returned by <code>vector_pro::end</code>, but it cannot be used to modify the contents it points to, even if the vector object is not itself const.</p> <p>If the container is empty, this function returns the same as <code>vector_pro::cbegin</code>.</p>"},{"location":"functions/cend/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/cend/#return-value","title":"Return value","text":"<p>A <code>const_iterator_pro</code> to the end of the sequence.</p>"},{"location":"functions/cend/#example","title":"Example","text":"C++<pre><code>// vector_pro::cbegin/cend\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 10 20 30 40 50\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30,40,50};\n\n  std::cout &lt;&lt; \"myvector contains:\";\n\n  for (auto it = myvector.cbegin(); it != myvector.cend(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/cend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/clear/","title":"vector_pro::clear","text":"C++<pre><code>void clear() noexcept;\n</code></pre>"},{"location":"functions/clear/#return-const_iterator-to-beginning","title":"Return const_iterator to beginning","text":"<p>Removes all elements from the vector (after destroyed), leaving the container with a size of <code>0</code>.</p>"},{"location":"functions/clear/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/clear/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/clear/#example","title":"Example","text":"C++<pre><code>// clearing vectors\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 100 200 300\n * myvector contains: 1101 2202\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  myvector.push_back (100);\n  myvector.push_back (200);\n  myvector.push_back (300);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  myvector.clear();\n  myvector.push_back (1101);\n  myvector.push_back (2202);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/clear/#complexity","title":"Complexity","text":"<p>Linear in size (destructions).</p>"},{"location":"functions/constructor/","title":"vector_pro::vector_pro","text":"C++<pre><code>vector_pro();\nvector_pro(const size_type len);\nvector_pro(const size_type len, const value_type&amp; val);\nvector_pro(const_iterator_pro&lt;value_type&gt;from, const_iterator_pro&lt;value_type&gt;exclude_to);\nvector_pro(const vector_pro&lt;value_type&gt;&amp; another);\nvector_pro(vector_pro&lt;value_type&gt;&amp;&amp; another);\nvector_pro(const std::vector&lt;value_type&gt;&amp; another);\nvector_pro(const std::initializer_list&lt;value_type&gt; &amp;another);\nvector_pro(const value_type *arr, const size_type len);\n</code></pre>"},{"location":"functions/constructor/#construct-vector","title":"Construct vector","text":"<p>Constructs a vector_pro, initializing its contents depending on the constructor version used:</p> <ol> <li> <p>default constructor Constructs an container, with <code>VECTOR_PRO_DEFAULT_SIZE</code>.</p> </li> <li> <p>fill constructor Constructs a container with <code>len</code> elements. Each element is a copy of <code>val</code> (if provided).</p> </li> <li> <p>range constructor Constructs a container with as many elements as the range <code>[from, exclude_to)</code> and in the same order.</p> </li> <li> <p>copy constructor Constructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>move constructor Constructs a container by moving each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>std::vector constructorConstructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>initializer list constructor Constructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> <li> <p>traditional array constructorConstructs a container with a copy of each of the elements in <code>another</code>, in the same order.</p> </li> </ol>"},{"location":"functions/constructor/#parameters","title":"Parameters","text":"<ol> <li><code>len</code>Initial container size.</li> <li><code>val</code>Value to fill the container with.</li> <li><code>another</code>Another container object of the same type.Can be a <code>std::vector</code> , <code>std::inializer_list</code> or just another <code>vector_pro</code>.</li> <li><code>from</code>, <code>exclude_to</code><code>Iterators</code> to the initial and final positions in a range. The range used is <code>[from, exclude_to)</code>, which includes all the elements between <code>from</code> and <code>exclude_to</code> , including the element pointed by <code>from</code> but not the element pointed by <code>exclude_to</code>. </li> <li><code>arr</code>Traditional array.</li> </ol>"},{"location":"functions/constructor/#example","title":"Example","text":"C++<pre><code>// constructing vectors\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * The contents of fifth are: [ 100, 100, 100, 100 ]\n * While in fourth will be: [ null ]\n */\n\nint main () {\n  // constructors used in the same order as described above:\n\n  // empty vector_pro of ints\n  vector_pro&lt;int&gt; first;     \n\n  // four ints with value 100\n  vector_pro&lt;int&gt; second (4,100);                       \n\n  // iterating through second\n  vector_pro&lt;int&gt; third (second.begin(),second.end());  \n\n  // a copy of third\n  vector_pro&lt;int&gt; fourth (third);\n\n  // a `move` from fourth\n  vector_pro&lt;int&gt; fifth (std::move(fourth));\n  std::cout &lt;&lt; \"The contents of fifth are: \" &lt;&lt; fifth &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"While in fourth will be: \" &lt;&lt; fourth &lt;&lt; std::endl;\n\n  // a copy from std::vector\n  std::vector&lt;int&gt; myints = {1, 2, 3, 4, 5};\n  vector_pro&lt;int&gt; sixth (myints);\n\n  // a copy from initializer list\n  vector_pro&lt;int&gt; seventh = {1, 2, 3, 4, 5};\n\n  // a copy from traditional array\n  int arr[5] = {0, 1, 2, 3, 4};\n  vector_pro&lt;int&gt; eighth (arr, 5);\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/constructor/#complexity","title":"Complexity","text":"<p>Constant for the <code>default constructor</code> (1), and for the <code>move constructors</code> (3) . For all other cases, linear in the resulting container size.</p>"},{"location":"functions/crbegin/","title":"vector_pro::crbegin","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; crbegin() const noexcept;\n</code></pre>"},{"location":"functions/crbegin/#return-const_iterator-to-reverse-beginning","title":"Return const_iterator to reverse beginning","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the last element in the container and grows in a reverse way. </p>"},{"location":"functions/crbegin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/crbegin/#return-value","title":"Return value","text":"<p>A <code>const_iterator_pro</code> to the reverse beginning of the sequence.</p>"},{"location":"functions/crbegin/#example","title":"Example","text":"C++<pre><code>// vector_pro::crbegin/crend\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector backwards: 5 4 3 2 1\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {1,2,3,4,5};\n\n  std::cout &lt;&lt; \"myvector backwards:\";\n  for (auto rit = myvector.crbegin(); rit != myvector.crend(); ++rit)\n    std::cout &lt;&lt; ' ' &lt;&lt; *rit;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/crbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/crend/","title":"vector_pro::crend","text":"C++<pre><code>const_iterator_pro&lt;value_type&gt; crend() const noexcept;\n</code></pre>"},{"location":"functions/crend/#return-const_iterator-to-reverse-end","title":"Return const_iterator to reverse end","text":"<p>Returns a <code>const_iterator_pro</code> pointing to the first element in the container and grows in a reverse way. </p>"},{"location":"functions/crend/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/crend/#return-value","title":"Return value","text":"<p>A <code>const_iterator_pro</code> to the reverse end of the sequence.</p>"},{"location":"functions/crend/#example","title":"Example","text":"C++<pre><code>// vector_pro::crbegin/crend\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector backwards: 5 4 3 2 1\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {1,2,3,4,5};\n\n  std::cout &lt;&lt; \"myvector backwards:\";\n  for (auto rit = myvector.crbegin(); rit != myvector.crend(); ++rit)\n    std::cout &lt;&lt; ' ' &lt;&lt; *rit;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/crend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/data/","title":"vector_pro::data","text":"C++<pre><code>value_type *data() const;\n</code></pre>"},{"location":"functions/data/#do-nothing","title":"Do nothing","text":"<p>Due to the data structure used in <code>vector_pro</code>, <code>vector_pro</code> doesn't support this operation yet. (Maybe in the near future ?) </p>"},{"location":"functions/data/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/data/#return-value","title":"Return value","text":"<p>Throw an exception.</p>"},{"location":"functions/data/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/destructor/","title":"vector_pro::~vector_pro","text":"C++<pre><code>~vector_pro();\n</code></pre>"},{"location":"functions/destructor/#destruct-vector","title":"Destruct vector","text":"<p>Destroys the container object, after destructs each element by calling <code>~value_type()</code> (if has).</p>"},{"location":"functions/destructor/#complexity","title":"Complexity","text":"<p>Linear in size (destructors).</p>"},{"location":"functions/emplace/","title":"vector_pro::emplace","text":"C++<pre><code>size_type emplace(size_type position, const value_type&amp; val);\niterator_pro&lt;value_type&gt; emplace(iterator_pro&lt;value_type&gt; position, const value_type&amp; val);\nconst_iterator_pro&lt;value_type&gt; emplace(const_iterator_pro&lt;value_type&gt; position, const value_type&amp; val);\n</code></pre>"},{"location":"functions/emplace/#construct-and-insert-element","title":"Construct and insert element","text":"<p>The container is extended by inserting a new element <code>val</code> at <code>position</code>. </p> <p>This effectively increases the container size by one.</p> <p>An automatic reallocation of the allocated storage space happens if -and only if- the new vector size surpasses the current vector capacity.</p> <p>A similar member function exists, <code>vector_pro::insert</code> , which either copies or moves existing objects into the container.</p> <p>Please note that if the variable <code>position</code> exceeds the bounds of the vector, this function will throw an <code>exception</code> .</p>"},{"location":"functions/emplace/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position in the container where the new element is inserted.Can be <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code>.</li> <li><code>val</code>Value of the new element.</li> </ol>"},{"location":"functions/emplace/#return-value","title":"Return value","text":"<p>An position that points to the newly emplaced element.</p> <p>Type will be same as the position. ( <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> )</p>"},{"location":"functions/emplace/#example","title":"Example","text":"C++<pre><code>// vector_pro::emplace\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 10 200 100 20 30 300\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30};\n\n  auto it = myvector.emplace ( myvector.begin()+1, 100 );\n  myvector.emplace ( it, 200 );\n  myvector.emplace ( myvector.end(), 300 );\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (auto&amp; x: myvector)\n    std::cout &lt;&lt; ' ' &lt;&lt; x;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/emplace/#complexity","title":"Complexity","text":"<p>Linear on the number of elements after position (moving).</p>"},{"location":"functions/emplace_back/","title":"vector_pro::emplace","text":"C++<pre><code>size_type emplace_back(const value_type&amp; val);\n</code></pre>"},{"location":"functions/emplace_back/#construct-and-insert-element-at-the-end","title":"Construct and insert element at the end","text":"<p>Inserts a new element at the end of the vector, right after its current last element.</p> <p>A similar member function exists, <code>vector_pro::push_back</code> , which either copies or moves an existing object into the container.</p>"},{"location":"functions/emplace_back/#parameters","title":"Parameters","text":"<ol> <li><code>val</code>Value of the new element.</li> </ol>"},{"location":"functions/emplace_back/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/emplace_back/#example","title":"Example","text":"C++<pre><code>// vector_pro::emplace_back\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 10 20 30 100 200\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = {10,20,30};\n\n  myvector.emplace_back (100);\n  myvector.emplace_back (200);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (auto&amp; x: myvector)\n    std::cout &lt;&lt; ' ' &lt;&lt; x;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/emplace_back/#complexity","title":"Complexity","text":"<p>Constant (amortized time, reallocation may happen).</p>"},{"location":"functions/empty/","title":"vector_pro::empty","text":"C++<pre><code>bool empty() const noexcept;\n</code></pre>"},{"location":"functions/empty/#test-whether-the-container-is-empty","title":"Test whether the container is empty","text":"<p>Returns whether the vector is empty (i.e. whether its size is <code>0</code>).</p>"},{"location":"functions/empty/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/empty/#return-value","title":"Return value","text":"<p><code>true</code> if the container size is <code>0</code>, <code>false</code> otherwise.</p>"},{"location":"functions/empty/#example","title":"Example","text":"C++<pre><code>// vector_pro::empty\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * total: 55\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  int sum (0);\n\n  for (int i=1;i&lt;=10;i++) myvector.push_back(i);\n\n  while (!myvector.empty())\n  {\n     sum += myvector.back();\n     myvector.pop_back();\n  }\n\n  std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/empty/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/end/","title":"vector_pro::end","text":"C++<pre><code>iterator_pro end() noexcept;\n</code></pre>"},{"location":"functions/end/#return-iterator-to-beginning","title":"Return iterator to beginning","text":"<p>Returns an <code>iterator</code> pointing to the <code>past-the-end</code> element in the vector.</p> <p>If the container is empty, the returned iterator value shall not be dereferenced.</p>"},{"location":"functions/end/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/end/#return-value","title":"Return value","text":"<p>An <code>iterator_pro</code> to the element past the end of the sequence.</p>"},{"location":"functions/end/#example","title":"Example","text":"C++<pre><code>// vector_pro::begin/end\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 1 2 3 4 5\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  for (int i=1; i&lt;=5; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (iterator_pro&lt;int&gt; it = myvector.begin() ; it != myvector.end(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/end/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/erase/","title":"vector_pro::erase","text":"C++<pre><code>size_type erase(size_type position);\nsize_type erase(size_type from, size_type exclude_to);\niterator_pro&lt;value_type&gt; erase(const_iterator_pro&lt;value_type&gt; position);\niterator_pro&lt;value_type&gt; erase(const_iterator_pro&lt;value_type&gt; from, const_iterator_pro&lt;value_type&gt; exclude_to);\n</code></pre>"},{"location":"functions/erase/#erase-elements","title":"Erase elements","text":"<p>Removes from the vector either a single element ( <code>position</code> ) or a range of elements ( <code>[from, exclude_to)</code> ).</p> <p>This effectively reduces the container size by the number of elements removed, which are destroyed.</p> <p>Please note that if the variables <code>position</code>,  <code>from</code>, or <code>exclude_to</code> exceed the bounds of the vector, this function will throw an <code>exception</code> . You will also get one when <code>from</code> is gt <code>exclude_to</code> .</p>"},{"location":"functions/erase/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position in the container where the target element is.Can be <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> .</li> <li><code>from</code> ,  <code>exclude_to</code>The range of elements we are going to erase.Can be  <code>size_type</code>s or  <code>(const_)iterator_pro</code>s.The range includes all the elements between <code>from</code> and <code>exclude_to</code>, including the element pointed by <code>from</code> but not the one pointed by <code>exclude_to</code>.</li> </ol>"},{"location":"functions/erase/#return-value","title":"Return value","text":"<p>The return value will point to the new location of the element that followed the last element erased by the function call.</p> <p>Type will be same as the position. (<code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> )</p>"},{"location":"functions/erase/#example","title":"Example","text":"C++<pre><code>// erasing from vector_pro\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 4 5 7 8 9 10\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some values (from 1 to 10)\n  for (int i=1; i&lt;=10; i++) myvector.push_back(i);\n\n  // erase the 6th element\n  myvector.erase (myvector.begin()+5);\n\n  // erase the first 3 elements:\n  myvector.erase (myvector.begin(),myvector.begin()+3);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;myvector.size(); ++i)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/erase/#complexity","title":"Complexity","text":"<p>Linear on the number of elements erased (destructions) plus the number of elements after the last element deleted (moving).</p>"},{"location":"functions/front/","title":"vector_pro::front","text":"C++<pre><code>value_type&amp; front();\n</code></pre>"},{"location":"functions/front/#access-element","title":"Access element","text":"<p>Returns a reference to the first element in the vector. </p> <p>Please note that calling this function on an empty will get an exception .</p>"},{"location":"functions/front/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/front/#return-value","title":"Return value","text":"<p>A reference to the first element in the vector.</p>"},{"location":"functions/front/#example","title":"Example","text":"C++<pre><code>// vector_pro::front\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector.front() is now 62\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  myvector.push_back(78);\n  myvector.push_back(16);\n\n  // now front equals 78, and back 16\n\n  myvector.front() -= myvector.back();\n\n  std::cout &lt;&lt; \"myvector.front() is now \" &lt;&lt; myvector.front() &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/front/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/insert/","title":"vector_pro::insert","text":"C++<pre><code>size_type insert(size_type position, const value_type&amp; val);\n\niterator_pro&lt;value_type&gt; insert(iterator_pro&lt;value_type&gt; position, const value_type&amp; val);\niterator_pro&lt;value_type&gt; insert(iterator_pro&lt;value_type&gt; position, size_type num, const value_type&amp; val);\niterator_pro&lt;value_type&gt; insert(iterator_pro&lt;value_type&gt; position, const_iterator_pro&lt;value_type&gt; from, const_iterator_pro&lt;value_type&gt; exclude_to);\niterator_pro&lt;value_type&gt; insert(iterator_pro&lt;value_type&gt; position, const std::initializer_list&lt;value_type&gt;&amp; li);\n\nconst_iterator_pro&lt;value_type&gt; insert(const_iterator_pro&lt;value_type&gt; position, const value_type&amp; val);\nconst_iterator_pro&lt;value_type&gt; insert(const_iterator_pro&lt;value_type&gt; position, size_type num, const value_type&amp; val);\nconst_iterator_pro&lt;value_type&gt; insert(const_iterator_pro&lt;value_type&gt; position, const_iterator_pro&lt;value_type&gt; from, const_iterator_pro&lt;value_type&gt; exclude_to);\nconst_iterator_pro&lt;value_type&gt; insert(const_iterator_pro&lt;value_type&gt; position, const std::initializer_list&lt;value_type&gt;&amp; li);\n</code></pre>"},{"location":"functions/insert/#insert-elements","title":"Insert elements","text":"<p>The vector is extended by inserting new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted.</p> <p>This causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity.</p> <p>Because vectors use an array as their underlying storage, inserting elements in positions other than the vector end causes the container to relocate all the elements that were after <code>position</code> to their new positions. This is generally an inefficient operation compared to the one performed for the same operation by other kinds of sequence containers (such as list or forward_list).</p>"},{"location":"functions/insert/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position in the container where the new elements are inserted.Can be <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> .</li> <li><code>val</code>Value to be copied to the inserted elements.</li> <li><code>num</code>Number of elements to insert. Each element is initialized to a copy of <code>val</code>.</li> <li><code>from</code> ,  <code>exclude_to</code>The range of elements we are going to insert.Can be <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> .The range includes all the elements between <code>from</code> and <code>exclude_to</code>, including the element pointed by <code>from</code> but not the one pointed by <code>exclude_to</code>.</li> <li><code>li</code>An initializer_list object. Copies of these elements are inserted at <code>position</code> (in the same order).</li> </ol>"},{"location":"functions/insert/#return-value","title":"Return value","text":"<p>The return value will point to the first of the newly inserted elements.</p> <p>Type will be same as the position. ( <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> )</p>"},{"location":"functions/insert/#example","title":"Example","text":"C++<pre><code>// inserting into a vector_pro\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 501 502 503 300 300 400 400 200 100 100 100\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector (3,100);\n  iterator_pro&lt;int&gt; it;\n\n  it = myvector.begin();\n  it = myvector.insert ( it , 200 );\n\n  myvector.insert (it,2,300);\n\n  // \"it\" no longer valid, get a new one:\n  it = myvector.begin();\n\n  vector_pro&lt;int&gt; anothervector (2,400);\n  myvector.insert (it+2,anothervector.begin(),anothervector.end());\n\n  std::initializer_list&lt;int&gt; myarray = { 501,502,503 };\n  myvector.insert (myvector.begin(), myarray);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (it=myvector.begin(); it != myvector.end(); it++)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/insert/#complexity","title":"Complexity","text":"<p>Linear on the number of elements inserted (copy/move construction) plus the number of elements after <code>position</code> (moving).</p>"},{"location":"functions/max_size/","title":"vector_pro::max_size","text":"C++<pre><code>size_t max_size() const noexcept;\n</code></pre>"},{"location":"functions/max_size/#return-maximum-size","title":"Return maximum size","text":"<p>Returns the maximum number of elements that the vector can hold.</p>"},{"location":"functions/max_size/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/max_size/#return-value","title":"Return value","text":"<p>The maximum number of elements a vector container can hold as content.</p>"},{"location":"functions/max_size/#example","title":"Example","text":"C++<pre><code>// comparing size, capacity and max_size\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * size: 100\n * capacity: 128\n * max_size: 9223372036854775807\n */\n\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some content in the vector:\n  for (int i=0; i&lt;100; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"max_size: \" &lt;&lt; (std::size_t) myvector.max_size() &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/max_size/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/operator%3D/","title":"vector_pro::operator=","text":"C++<pre><code>void operator= (const vector_pro&lt;value_type&gt;&amp; another);\nvoid operator= (vector_pro&lt;value_type&gt;&amp;&amp; another);\nvoid operator= (const std::vector&lt;value_type&gt;&amp; another);\nvoid operator= (const std::initializer_list&lt;value_type&gt;&amp; another);\n</code></pre>"},{"location":"functions/operator%3D/#assign-content","title":"Assign content","text":"<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.</p> <ol> <li><code>copy assignment</code>Copies all the elements from <code>another</code> into the container.</li> <li><code>move assignment</code>Moves all the elements from <code>another</code> into the container.</li> <li><code>std::vector assignment</code>Copies all the elements from <code>another</code> into the container.</li> <li><code>initializer list assignment</code>Copies all the elements from <code>another</code> into the container.</li> </ol>"},{"location":"functions/operator%3D/#parameters","title":"Parameters","text":"<ol> <li><code>another</code>Can be a <code>std::vector</code> , <code>std::inializer_list</code> or just another <code>vector_pro</code>.</li> </ol>"},{"location":"functions/operator%3D/#return-value","title":"Return value","text":"<p><code>*this</code> .</p>"},{"location":"functions/operator%3D/#example","title":"Example","text":"C++<pre><code>// vector_pro::operator=\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * Size of foo: 0\n * Size of bar: 3\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; foo (3,0);\n  vector_pro&lt;int&gt; bar (5,0);\n\n  bar = foo;\n  foo = vector_pro&lt;int&gt;();\n\n  std::cout &lt;&lt; \"Size of foo: \" &lt;&lt; int(foo.size()) &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"Size of bar: \" &lt;&lt; int(bar.size()) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/operator%3D/#complexity","title":"Complexity","text":"<p>Linear in size.</p>"},{"location":"functions/operator%5B%5D/","title":"vector_pro::operator[ ]","text":"C++<pre><code>value_type&amp; operator[](size_type position);\n</code></pre>"},{"location":"functions/operator%5B%5D/#access-element","title":"Access element","text":"<p>Returns a reference to the element at <code>position</code> in the vector container.</p> <p>Please note that the function automatically checks whether <code>position</code> is within the bounds of valid elements in the vector, throwing an <code>exception</code> if it is not. </p> <p><code>std::vector</code> doesn't do this.</p>"},{"location":"functions/operator%5B%5D/#parameters","title":"Parameters","text":"<ol> <li><code>position</code>Position of an element in the container.</li> </ol>"},{"location":"functions/operator%5B%5D/#return-value","title":"Return value","text":"<p>The reference of the element at the specified position in the container.</p>"},{"location":"functions/operator%5B%5D/#example","title":"Example","text":"C++<pre><code>// vector_pro::operator[]\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 9 8 7 6 5 4 3 2 1 0\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector (10, 0);   // 10 zero-initialized elements\n\n  size_type sz = myvector.size();\n\n  // assign some values:\n  for (unsigned i=0; i&lt;sz; i++) myvector[i]=i;\n\n  // reverse vector using operator[]:\n  for (unsigned i=0; i&lt;sz/2; i++)\n  {\n    int temp;\n    temp = myvector[sz-1-i];\n    myvector[sz-1-i]=myvector[i];\n    myvector[i]=temp;\n  }\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (unsigned i=0; i&lt;sz; i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/operator%5B%5D/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/pop_back/","title":"vector_pro::pop_back","text":"C++<pre><code>void pop_back();\n</code></pre>"},{"location":"functions/pop_back/#delete-last-element","title":"Delete last element","text":"<p>Removes the last element in the vector, effectively reducing the container size by one.</p> <p>This destroys the removed element.</p> <p>Please note that calling this function on an empty container will get an <code>exception</code>.</p> <p>See also vector_pro::pop()</p>"},{"location":"functions/pop_back/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/pop_back/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/pop_back/#example","title":"Example","text":"C++<pre><code>// vector_pro::pop_back\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * The elements of myvector add up to 600\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  int sum (0);\n  myvector.push_back (100);\n  myvector.push_back (200);\n  myvector.push_back (300);\n\n  while (!myvector.empty())\n  {\n    sum+=myvector.back();\n    myvector.pop_back();\n  }\n\n  std::cout &lt;&lt; \"The elements of myvector add up to \" &lt;&lt; sum &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/pop_back/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/push_back/","title":"vector_pro::push_back","text":"C++<pre><code>void push_back(const value_type&amp; val);\n</code></pre>"},{"location":"functions/push_back/#add-element-at-the-end","title":"Add element at the end","text":"<p>Adds a new element at the end of the vector, after its current last element. The content of <code>val</code> is copied to the new element.</p> <p>This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity.</p> <p>Same as vector_pro::push()</p>"},{"location":"functions/push_back/#parameters","title":"Parameters","text":"<ol> <li><code>val</code>Value to be copied to the new element.</li> </ol>"},{"location":"functions/push_back/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/push_back/#example","title":"Example","text":"C++<pre><code>// vector_pro::push_back/push\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * The example uses push_back to add a new element to the vector each time a new integer is read.\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  int myint;\n\n  std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\";\n\n  do {\n    std::cin &gt;&gt; myint;\n    myvector.push_back (myint);\n  } while (myint);\n\n  std::cout &lt;&lt; \"myvector stores \" &lt;&lt; int(myvector.size()) &lt;&lt; \" numbers.\\n\";\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/push_back/#complexity","title":"Complexity","text":"<p>Constant (amortized time, reallocation may happen).</p>"},{"location":"functions/rbegin/","title":"vector_pro::rbegin","text":"C++<pre><code>iterator_pro&lt;value_type&gt; rbegin() const noexcept;\n</code></pre>"},{"location":"functions/rbegin/#return-iterator-to-reverse-beginning","title":"Return iterator to reverse beginning","text":"<p>Returns an <code>iterator_pro</code> pointing to the last element in the container and grows in a reverse way. </p>"},{"location":"functions/rbegin/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/rbegin/#return-value","title":"Return value","text":"<p>An <code>iterator_pro</code> to the reverse beginning of the sequence.</p>"},{"location":"functions/rbegin/#example","title":"Example","text":"C++<pre><code>// vector_pro::rbegin/rend\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 5 4 3 2 1\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector (5, 0);  // 5 default-constructed ints\n\n  int i=0;\n\n  iterator_pro&lt;int&gt; rit = myvector.rbegin();\n  for (; rit!= myvector.rend(); ++rit)\n    *rit = ++i;\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (auto it = myvector.begin(); it != myvector.end(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/rbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/rend/","title":"vector_pro::rend","text":"C++<pre><code>iterator_pro&lt;value_type&gt; rend() const noexcept;\n</code></pre>"},{"location":"functions/rend/#return-iterator-to-reverse-beginning","title":"Return iterator to reverse beginning","text":"<p>Returns a <code>iterator_pro</code> pointing to the first element in the container and grows in a reverse way. </p>"},{"location":"functions/rend/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/rend/#return-value","title":"Return value","text":"<p>A <code>iterator_pro</code> to the reverse end of the sequence.</p>"},{"location":"functions/rend/#example","title":"Example","text":"C++<pre><code>// vector_pro::rbegin/rend\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 5 4 3 2 1\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector (5, 0);  // 5 default-constructed ints\n\n  int i=0;\n\n  iterator_pro&lt;int&gt; rit = myvector.rbegin();\n  for (; rit!= myvector.rend(); ++rit)\n    *rit = ++i;\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (auto it = myvector.begin(); it != myvector.end(); ++it)\n    std::cout &lt;&lt; ' ' &lt;&lt; *it;\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/rend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/reserve/","title":"vector_pro::reserve","text":"C++<pre><code>void reserve(const size_type re_size);\n</code></pre>"},{"location":"functions/reserve/#request-a-change-in-capacity","title":"Request a change in capacity","text":"<p>Requests that the vector capacity be at least enough to contain <code>re_size</code> elements.</p> <p>If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to <code>re_size</code> (or greater).</p> <p>In all other cases, the function call does not cause a reallocation and the vector capacity is not affected.</p> <p>This function has no effect on the vector size and cannot alter its elements.</p>"},{"location":"functions/reserve/#parameters","title":"Parameters","text":"<ol> <li><code>re_size</code>Minimum capacity for the vector.</li> </ol>"},{"location":"functions/reserve/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/reserve/#example","title":"Example","text":"C++<pre><code>// vector_pro::reserve\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * making foo grow:\n * capacity changed: 128\n * making bar grow:\n * capacity changed: 100\n */\n\nint main ()\n{\n  size_type sz;\n\n  vector_pro&lt;int&gt; foo;\n  sz = foo.capacity();\n  std::cout &lt;&lt; \"making foo grow:\\n\";\n  for (int i=0; i&lt;100; ++i) {\n    foo.push_back(i);\n    if (sz!=foo.capacity()) {\n      sz = foo.capacity();\n      std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n';\n    }\n  }\n\n  vector_pro&lt;int&gt; bar;\n  sz = bar.capacity();\n  bar.reserve(100);   // this is the only difference with foo above\n  std::cout &lt;&lt; \"making bar grow:\\n\";\n  for (int i=0; i&lt;100; ++i) {\n    bar.push_back(i);\n    if (sz!=bar.capacity()) {\n      sz = bar.capacity();\n      std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n';\n    }\n  }\n  return 0;\n}\n</code></pre>"},{"location":"functions/reserve/#complexity","title":"Complexity","text":"<p>If a reallocation happens, linear in vector size at most.</p>"},{"location":"functions/resize/","title":"vector_pro::resize","text":"C++<pre><code>void resize(const size_type re_size);\nvoid resize(const size_type re_size, const value_type&amp; val);\n</code></pre>"},{"location":"functions/resize/#change-size","title":"Change size","text":"<p>Resizes the container so that it contains <code>re_size</code> elements.</p> <p>If <code>re_size</code> is smaller than the current container size, the content is reduced to its first <code>re_size</code> elements, removing those beyond (and destroying them).</p> <p>Different from <code>std::vector</code> , the capacity will shrink to <code>re_size</code> .</p> <p>If <code>re_size</code> is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of <code>re_size</code>.  If <code>val</code> is specified, the new elements are initialized as copies of <code>val</code> .</p> <p>Different from <code>std::vector</code> , if <code>val</code> is not specified, <code>vector_pro</code> will do nothing.</p> <p>If <code>re_size</code> is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place.</p> <p>Notice that this function changes the actual content of the container by inserting or erasing elements from it.</p>"},{"location":"functions/resize/#parameters","title":"Parameters","text":"<ol> <li><code>re_size</code>New container size, expressed in number of elements.</li> <li><code>val</code>Object whose content is copied to the added elements in case that n is greater than the current container size.</li> </ol>"},{"location":"functions/resize/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/resize/#example","title":"Example","text":"C++<pre><code>// resizing vector_pro\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains: 1 2 3 4 5 100 100 100\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some initial content:\n  for (int i=1;i&lt;10;i++) myvector.push_back(i);\n\n  myvector.resize(5);\n  myvector.resize(8,100);\n  myvector.resize(12);\n\n  std::cout &lt;&lt; \"myvector contains:\";\n  for (int i=0;i&lt;myvector.size();i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/resize/#complexity","title":"Complexity","text":"<p>Linear on the number of elements inserted/erased (constructions/destructions).</p> <p>If a reallocation happens, the reallocation is itself up to linear in the entire vector size.</p>"},{"location":"functions/shrink_to_fit/","title":"vector_pro::shrink_to_fit","text":"C++<pre><code>void shrink_to_fit();\n</code></pre>"},{"location":"functions/shrink_to_fit/#shrink-to-fit","title":"Shrink to fit","text":"<p>Requests the container to reduce its capacity to fit its size.</p>"},{"location":"functions/shrink_to_fit/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/shrink_to_fit/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/shrink_to_fit/#example","title":"Example","text":"C++<pre><code>// vector_pro::shrink_to_fit\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * 1. capacity of myvector: 100\n * 2. capacity of myvector: 10\n * 3. capacity of myvector: 10\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector (100, 0);\n  std::cout &lt;&lt; \"1. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n';\n\n  myvector.resize(10);\n  std::cout &lt;&lt; \"2. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n';\n\n  myvector.shrink_to_fit();\n  std::cout &lt;&lt; \"3. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/shrink_to_fit/#complexity","title":"Complexity","text":"<p>At most, linear in container size.</p>"},{"location":"functions/size/","title":"vector_pro::size","text":"C++<pre><code>size_type size() const noexcept;\n</code></pre>"},{"location":"functions/size/#return-size","title":"Return size","text":"<p>Returns the number of elements in the vector.</p> <p>This is the number of actual objects held in the vector, which is not necessarily equal to its storage capacity.</p>"},{"location":"functions/size/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"functions/size/#return-value","title":"Return value","text":"<p>The number of elements in the container.</p>"},{"location":"functions/size/#example","title":"Example","text":"C++<pre><code>// comparing size, capacity and max_size\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * size: 100\n * capacity: 128\n * max_size: 9223372036854775807\n */\n\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some content in the vector:\n  for (int i=0; i&lt;100; i++) myvector.push_back(i);\n\n  std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"max_size: \" &lt;&lt; (std::size_t) myvector.max_size() &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"functions/size/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"functions/swap/","title":"vector_pro::swap","text":"C++<pre><code>void swap(const size_type idx1, const size_type idx2);\nvoid swap(const_iterator_pro&lt;value_type&gt; idx1, const_iterator_pro&lt;value_type&gt; idx2)\nvoid swap(vector_pro&lt;value_type&gt; &amp;another);\n</code></pre>"},{"location":"functions/swap/#swap-content","title":"Swap content","text":"<ol> <li>Swap contents between two index ( 1. 2. ): After calling this function, the contents at the two indexes will be moved to another index.</li> <li>Swap containers ( 3. ): After the call to this member function, the elements in this container are those which were in <code>another</code> before the call, and the elements of <code>another</code> are those which were in this. All iterators, references and pointers remain valid for the swapped objects.</li> </ol> <p>Different from <code>std::vector</code> , the <code>vector_pro::swap</code> has two using ways.</p> <p>Please note that calling the function by passing illegal <code>idx1</code> or <code>idx2</code> will get an exception.</p>"},{"location":"functions/swap/#parameters","title":"Parameters","text":"<ol> <li><code>idx1</code> , <code>idx2</code>Target index. (can be in different container but should have the same type)</li> <li><code>another</code>Another vector container of the same type</li> </ol>"},{"location":"functions/swap/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"functions/swap/#example","title":"Example","text":"C++<pre><code>// vector_pro::swap\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * foo contains: 200 100 200 200 200\n * bar contains: 100 100 200\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; foo (3,100);   // three ints with a value of 100\n  vector_pro&lt;int&gt; bar (5,200);   // five ints with a value of 200\n\n  foo.swap(bar);\n  foo.swap(bar.begin() + 2, foo.begin() + 1);\n\n  std::cout &lt;&lt; \"foo contains:\";\n  for (unsigned i=0; i&lt;foo.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; foo[i];\n  std::cout &lt;&lt; '\\n';\n\n  std::cout &lt;&lt; \"bar contains:\";\n  for (unsigned i=0; i&lt;bar.size(); i++)\n    std::cout &lt;&lt; ' ' &lt;&lt; bar[i];\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"functions/swap/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"new/const_iterator_pro/","title":"const_iterator_pro","text":"C++<pre><code>template &lt; class value_type &gt; class const_iterator_pro; // generic template\n</code></pre>"},{"location":"new/const_iterator_pro/#const-iterator-of-vector_pro","title":"Const iterator of <code>vector_pro</code>","text":"<p>You can get one by calling <code>vector_pro::cbegin</code>, <code>vector_pro::cend</code>, <code>vector_pro::crbegin</code> or <code>vector_pro::rend</code> .</p> <p>The return value will be an <code>const_iterator_pro</code> points to the beginning, end, reverse beginning and reverse end of the of the sequence respectively.</p> <p>By using the dereference operator <code>*</code> you can access the const data.</p> <p>Keep in mind that the type of the <code>reverse const iterator</code> is also <code>const_iterator_pro</code> but will move in an opposite way.</p> <p>Additionally, using <code>const_iterator_pro</code> for any operations or data access will not throw exceptions. Please ensure that memory errors will not occur when using it.</p> <p>See also <code>iterator_pro</code> .</p>"},{"location":"new/const_iterator_pro/#member-functions","title":"Member functions","text":"name notes (constructor) constructor (public member function) (destructor) destructor (public member function) C++<pre><code>// 1.\nsize_type get_idx() const;\n\n// 2.\nvalue_type** const get_data() const;\n\n// 3.\nbool get_reverse_flag() const;\n\n// 4.\nconst_iterator_pro operator++();\nconst_iterator_pro operator--();\n\n// 5.\nconst_iterator_pro operator++(int);\nconst_iterator_pro operator--(int);\n\n// 6.\nconst_iterator_pro operator+(const int step);\nconst_iterator_pro operator-(const int step);\n\n// 7.\nbool operator==(const iterator_pro&lt;value_type&gt;&amp; another) const;\nbool operator!=(const iterator_pro&lt;value_type&gt;&amp; another) const;\n\n// 8.\nconst value_type&amp; operator*();\n</code></pre> <ol> <li>Obtain the index of the data pointed to by <code>const_iterator_pro</code> in its container.</li> <li>Obtain the data of the container that <code>const_iterator_pro</code> points to.</li> <li>Whether the iterator is a reverse iterator.</li> <li>Return itself after moving the <code>const_iterator_pro</code> by one step.</li> <li>Return itself before moving the <code>const_iterator_pro</code> by one step</li> <li>Move the <code>const_iterator_pro</code> by a specified number of steps.</li> <li>Whether the two <code>const_iterator_pro</code>s point to the same data.</li> <li>Access the const data.</li> </ol> <p>If the iterator is a reversed one, both <code>++</code> / <code>--</code> and <code>+</code> / <code>-</code> will move <code>backward</code> / <code>forward</code> . </p> <p>Note that a <code>vector_pro</code> can convert into a <code>const_iterator_pro</code> , while the opposite is not true.</p>"},{"location":"new/const_iterator_pro/#example","title":"Example","text":"<p>See more in <code>vector_pro::cbegin</code>, <code>vector_pro::cend</code>, <code>vector_pro::crbegin</code> and <code>vector_pro::rend</code> .</p>"},{"location":"new/find/","title":"vector_pro::find","text":"C++<pre><code>size_type find(const value_type&amp; target, int(compare2)(const value_type &amp;, const value_type &amp;), size_type from = 0, size_type exclude_to = -1) const;\nsize_type find(const value_type&amp; target, size_type from = 0, size_type exclude_to = -1) const;\n\niterator_pro&lt;value_type&gt; find(const value_type&amp; target, int(compare2)(const value_type &amp;, const value_type &amp;), iterator_pro&lt;value_type&gt; from, iterator_pro&lt;value_type&gt; exclude_to) const;\niterator_pro&lt;value_type&gt; find(const value_type&amp; target, iterator_pro&lt;value_type&gt; from, iterator_pro&lt;value_type&gt; exclude_to) const;\n\nconst_iterator_pro&lt;value_type&gt; find(const value_type&amp; target, int(compare2)(const value_type &amp;, const value_type &amp;), const_iterator_pro&lt;value_type&gt; from, const_iterator_pro&lt;value_type&gt; exclude_to) const;\nconst_iterator_pro&lt;value_type&gt; find(const value_type&amp; target, const_iterator_pro&lt;value_type&gt; from, const_iterator_pro&lt;value_type&gt; exclude_to) const;\n</code></pre>"},{"location":"new/find/#find-an-element","title":"Find an element","text":"<p>Returns the position of the first element which is equal to the <code>target</code> .</p> <p>Please note that you must ensure your <code>value_type</code> implements the <code>==</code> comparison operator, or you must pass a function of the type <code>int(const value_type &amp;, const value_type &amp;)</code> as a parameter.</p> <p>Also note that calling the function by passing illegal <code>from</code> or <code>exclude_to</code> will get an exception. </p>"},{"location":"new/find/#parameters","title":"Parameters","text":"<ol> <li><code>target</code>The target value you are going to find.</li> <li><code>from</code> , <code>exclude_to</code>The range of elements we are find the target.Can be  <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> .If the types are <code>szie_type</code>s , the params have default values <code>0</code> (start of the container) and <code>-1</code> (end of the container). The range includes all the elements between <code>from</code> and <code>exclude_to</code>, including the element pointed by <code>from</code> but not the one pointed by <code>exclude_to</code>.</li> <li><code>int(compare2)(const value_type &amp;, const value_type &amp;)</code>To let us understand how to compare two <code>value_type</code>.</li> </ol>"},{"location":"new/find/#return-value","title":"Return value","text":"<p>The position of the first element which is equal to the <code>target</code> . </p> <p>The type will be same as the params. ( <code>size_type</code> / <code>iterator_pro</code> / <code>const_iterator_pro</code> )</p> <p>If nothing found, <code>-1</code> ( <code>size_type</code> ) or the <code>exclude_end</code> ( <code>iterator_pro</code> / <code>const_iterator_pro</code> ) will be returned.</p>"},{"location":"new/find/#example","title":"Example","text":"C++<pre><code>// vector_pro::find\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * (1) the nearest 9 is at:: 8\n * (2) the nearest 9 is at:: 11\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  // set some values (from 1 to 10)\n  for (int i=1; i&lt;=10; i++) myvector.push_back(i);\n  for (int i=10; i&gt;=0; i--) myvector.push_back(i);\n\n  // find the element 9 from the begin of container\n  auto idx = myvector.find (9, myvector.begin(), myvector.end());\n  std::cout &lt;&lt; \"(1) the nearest 9 is at:: \" &lt;&lt; idx.get_idx() &lt;&lt; \"\\n\";\n\n  // find the element 9 reversely from the end of container\n  auto idx2 = myvector.find (9, myvector.rbegin(), myvector.rend());\n  std::cout &lt;&lt; \"(2) the nearest 9 is at:: \" &lt;&lt; idx2.get_idx() &lt;&lt; \"\\n\";\n\n  return 0;\n}\n</code></pre>"},{"location":"new/find/#complexity","title":"Complexity","text":"<p>Linear on the number of elements in the range. </p>"},{"location":"new/iterator_pro/","title":"iterator_pro","text":"C++<pre><code>template &lt; class value_type &gt; class iterator_pro; // generic template\n</code></pre>"},{"location":"new/iterator_pro/#iterator-of-vector_pro","title":"Iterator of <code>vector_pro</code>","text":"<p>You can get one by calling <code>vector_pro::begin</code>, <code>vector_pro::end</code>, <code>vector_pro::rbegin</code> or <code>vector_pro::rend</code> .</p> <p>The return value will be an <code>iterator_pro</code> points to the beginning, end, reverse beginning and reverse end of the of the sequence respectively.</p> <p>By using the dereference operator <code>*</code> you can access the data.</p> <p>Keep in mind that the type of the <code>reverse iterator</code> is also <code>iterator_pro</code> but will move in an opposite way.</p> <p>Also note that <code>iterator_pro</code> and <code>std::iterator</code> are not compatible. </p> <p>Additionally, using <code>iterator_pro</code> for any operations or data access will not throw exceptions. Please ensure that memory errors will not occur when using it.</p> <p>See also <code>const_iterator_pro</code> .</p>"},{"location":"new/iterator_pro/#member-functions","title":"Member functions","text":"name notes (constructor) constructor (public member function) (destructor) destructor (public member function) C++<pre><code>// 1.\nsize_type get_idx() const;\n\n// 2.\nvalue_type** const get_data() const;\n\n// 3.\nbool get_reverse_flag() const;\n\n// 4.\niterator_pro operator++();\niterator_pro operator--();\n\n// 5.\niterator_pro operator++(int);\niterator_pro operator--(int);\n\n// 6.\niterator_pro operator+(const int step);\niterator_pro operator-(const int step);\n\n// 7.\nbool operator==(const iterator_pro&lt;value_type&gt;&amp; another) const;\nbool operator!=(const iterator_pro&lt;value_type&gt;&amp; another) const;\n\n// 8.\nvalue_type&amp; operator*();\n</code></pre> <ol> <li>Obtain the index of the data pointed to by <code>iterator_pro</code> in its container.</li> <li>Obtain the data of the container that <code>iterator_pro</code> points to.</li> <li>Whether the iterator is a reverse iterator.</li> <li>Return itself after moving the <code>iterator_pro</code> by one step.</li> <li>Return itself before moving the <code>iterator_pro</code> by one step</li> <li>Move the <code>iterator_pro</code> by a specified number of steps.</li> <li>Whether the two <code>iterator_pro</code>s point to the same data.</li> <li>Access the data.</li> </ol> <p>If the iterator is a reversed one, both <code>++</code> / <code>--</code> and <code>+</code> / <code>-</code> will move <code>backward</code> / <code>forward</code> . </p>"},{"location":"new/iterator_pro/#example","title":"Example","text":"<p>See more in <code>vector_pro::begin</code>, <code>vector_pro::end</code>, <code>vector_pro::rbegin</code> and <code>vector_pro::rend</code> .</p>"},{"location":"new/merge/","title":"vector_pro::merge","text":"C++<pre><code>// TODO\n</code></pre>"},{"location":"new/merge/#todo","title":"// TODO","text":"<p>// TODO</p>"},{"location":"new/merge/#parameters","title":"Parameters","text":"<p>// TODO</p>"},{"location":"new/merge/#return-value","title":"Return value","text":"<p>// TODO</p>"},{"location":"new/merge/#example","title":"Example","text":"C++<pre><code>// TODO\n</code></pre>"},{"location":"new/merge/#complexity","title":"Complexity","text":"<p>// TODO</p>"},{"location":"new/not_empty/","title":"vector_pro::not_empty","text":"C++<pre><code>bool not_empty() const noexcept;\n</code></pre>"},{"location":"new/not_empty/#test-whether-the-container-is-empty","title":"Test whether the container is empty","text":"<p>Returns whether the vector is not empty (i.e. whether its size more than <code>0</code>).</p>"},{"location":"new/not_empty/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"new/not_empty/#return-value","title":"Return value","text":"<p><code>false</code> if the container size is <code>0</code>, <code>true</code> otherwise.</p>"},{"location":"new/not_empty/#example","title":"Example","text":"C++<pre><code>// vector_pro::not_empty\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * total: 55\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  int sum (0);\n\n  for (int i=1;i&lt;=10;i++) myvector.push_back(i);\n\n  while (myvector.not_empty())\n  {\n     sum += myvector.back();\n     myvector.pop_back();\n  }\n\n  std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"new/not_empty/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"new/ostream/","title":"vector_pro::operator&lt;&lt;","text":"C++<pre><code>friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;output, const vector_pro&lt;value_type&gt;&amp; target) noexcept;\n</code></pre>"},{"location":"new/ostream/#stream-vector_pro-and-insert-into-stdostream","title":"Stream <code>vector_pro</code> and insert into <code>std::ostream</code>","text":"<p>Stream <code>vector_pro</code> and insert into <code>std::ostream</code>  .</p> <p>Please note that you must ensure your <code>value_type</code> implements the <code>&lt;&lt;</code> stream insertion operator.</p>"},{"location":"new/ostream/#parameters","title":"Parameters","text":"<ol> <li><code>output</code>The <code>std::ostream</code> .</li> <li><code>target</code>The container.</li> </ol>"},{"location":"new/ostream/#return-value","title":"Return value","text":"<p>The reference of <code>output</code> itself.</p>"},{"location":"new/ostream/#example","title":"Example","text":"C++<pre><code>// vector_pro::operator&lt;&lt;\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector contains:[ 32, 72, 55, 46, 32, 12, 61, 84, 39, 97 ]\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector = { 32, 72, 55, 46, 32, 12, 61, 84, 39, 97 };\n\n  std::cout &lt;&lt; \"myvector contains:\" &lt;&lt; myvector &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>"},{"location":"new/ostream/#complexity","title":"Complexity","text":"<p>Linear in size.</p>"},{"location":"new/pop/","title":"vector_pro::pop","text":"C++<pre><code>value_type pop();\n</code></pre>"},{"location":"new/pop/#pop-and-return-the-last-element","title":"Pop and return the last element","text":"<p>Return a copy of the last element ( Not a reference ) in the vector after destroying, effectively reducing the container size by one.</p> <p>See also vector_pro::pop_back()</p> <p>Please note that calling this function on an empty container will get an <code>exception</code>.</p> <p>It is not highly recommended to use this function; it has been implemented to be useful only in certain situations.</p>"},{"location":"new/pop/#parameters","title":"Parameters","text":"<p>none</p>"},{"location":"new/pop/#return-value","title":"Return value","text":"<p>A copy of the last element ( Not a reference ).</p>"},{"location":"new/pop/#example","title":"Example","text":"C++<pre><code>// vector_pro::pop\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * 300\n * 200\n * 100\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n\n  myvector.push_back (100);\n  myvector.push_back (200);\n  myvector.push_back (300);\n\n  std::cout &lt;&lt; myvector.pop() &lt;&lt; '\\n';\n  std::cout &lt;&lt; myvector.pop() &lt;&lt; '\\n';\n  std::cout &lt;&lt; myvector.pop() &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>"},{"location":"new/pop/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"new/print/","title":"vector_pro::print","text":"C++<pre><code>// TODO\n</code></pre>"},{"location":"new/print/#todo","title":"// TODO","text":"<p>// TODO</p>"},{"location":"new/print/#parameters","title":"Parameters","text":"<p>// TODO</p>"},{"location":"new/print/#return-value","title":"Return value","text":"<p>// TODO</p>"},{"location":"new/print/#example","title":"Example","text":"C++<pre><code>// TODO\n</code></pre>"},{"location":"new/print/#complexity","title":"Complexity","text":"<p>// TODO</p>"},{"location":"new/push/","title":"vector_pro::push","text":"C++<pre><code>void push(const value_type&amp; val);\n</code></pre>"},{"location":"new/push/#add-element-at-the-end","title":"Add element at the end","text":"<p>Adds a new element at the end of the vector, after its current last element. The content of <code>val</code> is copied to the new element.</p> <p>This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity.</p> <p>Same as vector::push_back()</p>"},{"location":"new/push/#parameters","title":"Parameters","text":"<ol> <li><code>val</code>Value to be copied to the new element.</li> </ol>"},{"location":"new/push/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"new/push/#example","title":"Example","text":"C++<pre><code>// vector_pro::push_back/push\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * The example uses push to add a new element to the vector each time a new integer is read.\n */\n\nint main ()\n{\n  vector_pro&lt;int&gt; myvector;\n  int myint;\n\n  std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\";\n\n  do {\n    std::cin &gt;&gt; myint;\n    myvector.push (myint);\n  } while (myint);\n\n  std::cout &lt;&lt; \"myvector stores \" &lt;&lt; int(myvector.size()) &lt;&lt; \" numbers.\\n\";\n\n  return 0;\n}\n</code></pre>"},{"location":"new/push/#complexity","title":"Complexity","text":"<p>Constant (amortized time, reallocation may happen).</p>"},{"location":"new/reverse/","title":"vector_pro::sort","text":"C++<pre><code>void sort() noexcept;\n\nvoid sort(int(compare2)(const value_type &amp;, const value_type &amp;)) noexcept;\n</code></pre>"},{"location":"new/reverse/#sort-the-vector","title":"Sort the vector","text":"<p>Sorts the vector by <code>Timsort</code>.</p> <p>To note that you must ensure your <code>value_type</code> implements the <code>&gt;</code> and the <code>&lt;</code> comparison operator, or you must pass a function of the type <code>int(const value_type &amp;, const value_type &amp;)</code> as a parameter.</p>"},{"location":"new/reverse/#parameters","title":"Parameters","text":"<ol> <li><code>int(compare2)(const value_type &amp;, const value_type &amp;)</code>To let us understand how to compare two <code>value_type</code>.</li> </ol>"},{"location":"new/reverse/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"new/reverse/#example","title":"Example","text":"C++<pre><code>// vector_pro::sort\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector is now:: [ 32, 72, 55, 46, 32, 12, 61, 84, 39, 97 ]\n * myvector after sorting:: [ 12, 32, 32, 39, 46, 55, 61, 72, 84, 97 ]\n */\n\nint main ()\n{\n\n  // push 10 elements into the container\n  vector_pro&lt;int&gt; myvector = { 32, 72, 55, 46, 32, 12, 61, 84, 39, 97 };\n  std::cout &lt;&lt; \"myvector is now:: \" &lt;&lt; myvector &lt;&lt; std::endl;\n\n  // sort\n  myvector.sort();\n  std::cout &lt;&lt; \"myvector after sorting:: \" &lt;&lt; myvector &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>"},{"location":"new/reverse/#complexity","title":"Complexity","text":"<p>Average performance will be \\(O(nlogn)\\). </p> <p>See also 1 and 2 .</p>"},{"location":"new/sort/","title":"vector_pro::sort","text":"C++<pre><code>void sort() noexcept;\n\nvoid sort(int(compare2)(const value_type &amp;, const value_type &amp;)) noexcept;\n</code></pre>"},{"location":"new/sort/#sort-the-vector","title":"Sort the vector","text":"<p>Sorts the vector by <code>Timsort</code>.</p> <p>To note that you must ensure your <code>value_type</code> implements the <code>&gt;</code> and the <code>&lt;</code> comparison operator, or you must pass a function of the type <code>int(const value_type &amp;, const value_type &amp;)</code> as a parameter.</p>"},{"location":"new/sort/#parameters","title":"Parameters","text":"<ol> <li><code>int(compare2)(const value_type &amp;, const value_type &amp;)</code>To let us understand how to compare two <code>value_type</code>.</li> </ol>"},{"location":"new/sort/#return-value","title":"Return value","text":"<p>none</p>"},{"location":"new/sort/#example","title":"Example","text":"C++<pre><code>// vector_pro::sort\n#include &lt;iostream&gt;\n#include \"vector_pro.h\"\n\n/**\n * Output:\n * myvector is now:: [ 32, 72, 55, 46, 32, 12, 61, 84, 39, 97 ]\n * myvector after sorting:: [ 12, 32, 32, 39, 46, 55, 61, 72, 84, 97 ]\n */\n\nint main ()\n{\n\n  // push 10 elements into the container\n  vector_pro&lt;int&gt; myvector = { 32, 72, 55, 46, 32, 12, 61, 84, 39, 97 };\n  std::cout &lt;&lt; \"myvector is now:: \" &lt;&lt; myvector &lt;&lt; std::endl;\n\n  // sort\n  myvector.sort();\n  std::cout &lt;&lt; \"myvector after sorting:: \" &lt;&lt; myvector &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>"},{"location":"new/sort/#complexity","title":"Complexity","text":"<p>Average performance will be \\(O(nlogn)\\). </p> <p>See also 1 and 2 .</p>"},{"location":"new/vector_pro_exception/","title":"vector_pro_exception","text":"C++<pre><code>class vector_pro_exception: public std::exception;\n</code></pre>"},{"location":"new/vector_pro_exception/#exception-thrown-by-vector_pro","title":"Exception thrown by <code>vector_pro</code>","text":"<p>When functions in <code>vector_pro</code> are used incorrectly or encounter exceptions, <code>vector_pro_exception</code> will be thrown. </p> <p>Same as <code>std::exception</code> , you can use <code>vector_pro_exception::what()</code> to obtain further information. </p> <p>The possible exceptions that may be thrown are described below.</p>"},{"location":"new/vector_pro_exception/#member-functions","title":"Member functions","text":"name notes (constructor) constructor (public member function) (destructor) destructor (public member function) what get info (public member function)"},{"location":"new/vector_pro_exception/#possible-exceptions","title":"Possible Exceptions","text":"<ol> <li><code>\"Initial size of vector should be geq 0.\"</code>Try to initialize a vector whose size is less than 0.Only being thrown by the constructor and the <code>operator=</code>.</li> <li><code>\"Out of memory.\"</code>Out of mem.</li> <li><code>\"Target array can't be null.\"</code>When use a <code>null</code> traditional array to initialize the container.Only being thrown by the constructor.</li> <li><code>\"Re_size val of vector should be geq 0.\"</code>Try to resize a vector whose size is less than 0.</li> <li><code>\"Out of range.\"</code>Try to access a position either when the container is empty or the position itself is out of range.</li> <li><code>\"Vector is empty.\"</code>Will be thrown by <code>vector_pro::front()</code> , <code>vector_pro::back()</code> , <code>vector_pro::pop()</code> and  <code>vector_pro::pop_back()</code> when the container is empty.</li> <li><code>\"Number of insert target should be geq 0.\"</code>Try to insert (or assign) less than 0 elements into the container.</li> <li><code>\"Iterator not of this vector.\"</code>Using a wrong iterator to access the current container.</li> <li><code>\"Iterator not of same vector.\"</code>Will be thrown in functions with the parameters <code>iterator_pro&lt;value_type&gt; from</code> and <code>iterator_pro&lt;value_type&gt; exclude_to</code>. The function will first check if the iterators belong to the same container before encountering further issues.</li> <li><code>\"Vector_pro doesn't support this operation yet. (Maybe in the near future ?)\"</code>See more in <code>vector_pro::data()</code> .</li> </ol>"},{"location":"tests/test1/","title":"test_title","text":"<p>// intro</p>"},{"location":"tests/test1/#test-code","title":"Test Code","text":"C++<pre><code>// code\n</code></pre> <p>///</p>"},{"location":"tests/test1/#result","title":"Result","text":"<p>///</p>"}]}